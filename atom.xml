<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈亮的个人博客</title>
  
  <subtitle>Coding Fantasy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenleon.me/"/>
  <updated>2020-03-29T07:33:12.513Z</updated>
  <id>http://chenleon.me/</id>
  
  <author>
    <name>Leon Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Opus 音频编码格式</title>
    <link href="http://chenleon.me/2020/03/15/opus-format/"/>
    <id>http://chenleon.me/2020/03/15/opus-format/</id>
    <published>2020-03-15T21:43:33.000Z</published>
    <updated>2020-03-29T07:33:12.513Z</updated>
    
    <content type="html"><![CDATA[<p>音频编码是将原始的音频采样数据，通过某种算法将其压缩编码成规定格式的二进制码流，从而方便存储和传输。Opus 就是由 <a href="https://xiph.org/" target="_blank" rel="noopener">Xiph.Org</a> 基金会发明的一种音频编码格式。</p><a id="more"></a><h2 id="opus-编码简介">Opus 编码简介</h2><p>音频信号处理中将音频（Audio）分为两大类：语音（Speech）和音乐（Music）。语音一般由人声带发出，人说话时语音的频率一般在 300 ~ 3400 Hz 之间，频率比较低。而音乐包含各种乐器演奏的声音，频率范围更广，涵盖了人耳能够听到的 20 ~ 20 kHz。由于两类音频频率范围各有特点，因此一般会采用不同的技术来处理。</p><p>Opus 编码格式应用了两种技术：一个是<strong>线性预测</strong>（Linear Prediction，LP），另一个是<strong>改进的离散余弦变换</strong>（Modified Discrete Cosine Transform，MDCT）。线性预测技术在低频信号的编码上更加高效，适合处理语音数据。对于包含高频信号的音乐，改进的离散余弦变换这种域变换技术处理效率更高。</p><p>Opus 编码格式采用的技术不是全新的，它使用的线性预测技术来自于 Skype 发明的 SILK 编解码器，而改进的离散余弦变换技术来自于 CELT （Constrained-Energy Lapped Transform）。CELT 也是由 <a href="https://xiph.org/" target="_blank" rel="noopener">Xiph.Org</a> 基金会早期发明一种音频编码格式，现在合并入 Opus 项目后，就不再有独立的 CELT 格式了。</p><p>为了对不同频率的音频应用不同的编码技术，Opus 音频频率带宽做了如下划分和命名：</p><table><thead><tr class="header"><th style="text-align: left;">缩写（全称）</th><th style="text-align: right;">音频带宽</th><th style="text-align: right;">应用采样率</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">NB (narrowband)</td><td style="text-align: right;">4 kHz</td><td style="text-align: right;">8 kHz</td></tr><tr class="even"><td style="text-align: left;">MB (medium-band)</td><td style="text-align: right;">6 kHz</td><td style="text-align: right;">12 kHz</td></tr><tr class="odd"><td style="text-align: left;">WB (wideband)</td><td style="text-align: right;">8 kHz</td><td style="text-align: right;">16 kHz</td></tr><tr class="even"><td style="text-align: left;">SWB (super-wideband)</td><td style="text-align: right;">12 kHz</td><td style="text-align: right;">24 kHz</td></tr><tr class="odd"><td style="text-align: left;">FB* (fullband)</td><td style="text-align: right;">20 kHz</td><td style="text-align: right;">48 kHz</td></tr></tbody></table><blockquote><p>根据奈奎斯特采样定理，应用 48 kHz 的采样率，实际上可以处理 24 kHz 以内的音频信号，但是即便如此，Opus 也不会处理超过 20 kHz 的音频，因为超过 20 kHz 的音频人耳已经很难听到了。</p></blockquote><p>Opus 编码器在处理音频的时候，会将音频划分成多个<strong>帧</strong>（Frame）之后，针对每帧来处理。Opus 支持的帧长有：2.5ms、5ms、10ms、20ms、40ms、60ms。</p><p>Opus 工作在 SILK 模式时，支持 NB、MB、WB 频率带宽的音频，并且帧长在 10ms ~ 60ms 之间。工作在 CELT 模式时，支持 NB、WB、SWB、FB 音频带宽，并且帧长在 2.5ms ~ 20ms 之间。Opus 还可以工作在混合模式（Hybrid），也就是 SILK 和 CELT 同时起作用，这种情况下只支持 SWB 、FB 音频带宽，并且帧长为 10ms 或 20ms。</p><h2 id="opus-包结构">Opus 包结构</h2><p>Opus 编码器处理原始数据输出一串包（Packet），一个包里面可能包含多个编码后的音频帧数据，只是这些音频帧的参数必须是一致的，例如：编码模式、音频带宽、帧大小以及声道数。</p><p>下面详细描述 Opus 包的结构。</p><h3 id="toc-字节">TOC 字节</h3><p>每个 Opus 包以一个 TOC （Table of Contents）字节开头，其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s| c |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这个字节由三部分组成：配置数（config），立体声标志（s），帧数（c）。</p><p>前 5 位的配置数定义了 32 种编码配置，不同的编码模式、音频带宽和帧长度组成了这 32 种配置，如下表所示：</p><table><thead><tr class="header"><th style="text-align: left;">配置数（config）</th><th style="text-align: left;">编码模式</th><th style="text-align: left;">音频带宽</th><th style="text-align: left;">帧长度</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0...3</td><td style="text-align: left;">SILK-only</td><td style="text-align: left;">NB</td><td style="text-align: left;">10, 20, 40, 60 ms</td></tr><tr class="even"><td style="text-align: left;">4...7</td><td style="text-align: left;">SILK-only</td><td style="text-align: left;">MB</td><td style="text-align: left;">10, 20, 40, 60 ms</td></tr><tr class="odd"><td style="text-align: left;">8...11</td><td style="text-align: left;">SILK-only</td><td style="text-align: left;">WB</td><td style="text-align: left;">10, 20, 40, 60 ms</td></tr><tr class="even"><td style="text-align: left;">12...13</td><td style="text-align: left;">Hybrid</td><td style="text-align: left;">SWB</td><td style="text-align: left;">10, 20 ms</td></tr><tr class="odd"><td style="text-align: left;">14...15</td><td style="text-align: left;">Hybrid</td><td style="text-align: left;">FB</td><td style="text-align: left;">10, 20 ms</td></tr><tr class="even"><td style="text-align: left;">16...19</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">NB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr><tr class="odd"><td style="text-align: left;">20...23</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">WB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr><tr class="even"><td style="text-align: left;">24...27</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">SWB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr><tr class="odd"><td style="text-align: left;">28...31</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">FB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr></tbody></table><p>立体声标志位（s）取值 0 表示单声道，1 表示多声道立体声。</p><p>TOC 中最后两位（c）表示：</p><ul><li>0：一个包中只有一帧音频。</li><li>1：一个包中有两帧音频，并且大小相同。</li><li>2：一个包中有两帧音频，但是大小不同。</li><li>3：一个包中有任意帧音频。</li></ul><h3 id="不同帧结构的包">不同帧结构的包</h3><p>根据一个包的 TOC 字节中帧数（c）的不同取值，我们把这个包命名为：<strong>c 号包</strong>。下面我们介绍这 4 种不同帧结构的包。</p><blockquote><p><strong>帧长度编码</strong><br />当一个包含有多个 VBR 的音频帧时，那么除了最后一个音频帧，前面几个帧都需要对帧的长度进行编码。存储帧长度的编码占用 1 ~ 2 个字节，其规则如下：<br />- 第一个字节取值为 0：表示没有任何帧数据（这通常是非连续传输（DTX）或者音频包丢失）<br />- 第一个字节取值为 1 ~ 251：表示第一帧的字节数<br />- 第一个字节取值为 252 ~ 255：第二个字节也参与编码帧长度，第一帧的总字节数为：<code>(第二字节*4)+第一字节</code></p><p>因此一个帧的最大长度为：255 * 4 + 255 = <strong>1275</strong> 字节。对于一个 20ms 的帧来说，这个长度代表 510 kbit/s 的码率。这个码率几乎是立体声音乐的有损压缩编码最高有效码率。超过这个码率，最好采用无损编码。这也是 MDCT 算法的最高有效码率，超过这个值，在增加码率进行编码，音频的质量也不会跟着提高。</p></blockquote><h4 id="号包-一个包只包含一帧音频">0 号包: 一个包只包含一帧音频</h4><p>其包结构如下，TOC 字节之后，紧跟着一帧音频的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|0|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+                                               |</span><br><span class="line">|                    Compressed frame 1 (N-1 bytes)...          :</span><br><span class="line">:                                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>后面这帧音频有可能是 0 个字节，这也是合法的 0 号包，这样的话这个包就只有一个 TOC 字节。</p><h4 id="号包-一个包里面含有两个大小相同的帧">1 号包: 一个包里面含有两个大小相同的帧</h4><p>TOC 字节后，紧跟着两个帧的数据，两个帧的大小各占这个包剩下字节数的一半。由此可以看出，1 号包的大小必定为奇数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|1|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+                                               :</span><br><span class="line">|             Compressed frame 1 ((N-1)&#x2F;2 bytes)...             |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|             Compressed frame 2 ((N-1)&#x2F;2 bytes)...             |</span><br><span class="line">:                                               +-+-+-+-+-+-+-+-+</span><br><span class="line">|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h4 id="号包-一个包里面含有两个大小不同的帧">2 号包: 一个包里面含有两个大小不同的帧</h4><p>这种情况下，因为一个音频包里面包含了两个大小不同的音频帧，因此需要对第一个帧的字节数编码，否则无法区分开两个帧。TOC 字节后面的 1 ~ 2 个字节为第一个帧的字节数，其规则如前面所述的<strong>帧长度编码</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|0| N1 (1-2 bytes):                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|                     Compressed frame 2...                     :</span><br><span class="line">:                                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h4 id="号包-一个包里面含有任意个帧">3 号包: 一个包里面含有任意个帧</h4><p>这种类型的包在 TOC 字节之后，有一个字节编码这个包里面的帧数量，这个字节的结构如下图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|v|p|     M     |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>帧数量字节包含三部分信息：</p><ul><li>v 等于 0 表示 CBR，等于 1 表示 VBR。</li><li>p 等于 1 表示包里面含有填充字节。</li><li>M 表示包里面含有的帧个数。</li></ul><p>规定一个包所包含的音频长度不能超过 120ms，如果按最小的帧长 2.5ms 计算，一个包的音频包所含有的音频帧不会超过 48 个。</p><p>当音频包里面含有填充字节时，帧数量字节后面的字节用于编码填充字节的长度。如果帧数量字节后面的那个字节值为 N (0~254)，则表示包后面的填充字节数加上当前这个表示填充字节长度的字节总共为 N 个字节。如果帧数量字节后面的那个字节值为 255，那么表示包后面的填充了254个字节，并且这个字节后面的一个字节编码了更多的填充字节数。以此类推，可以编码任意长度的填充字节数。</p><p>假如 P 表示填充字节的总数（包含编码填充字节长度的字节数），N 表示整个音频包的字节数。</p><p>那么对于 CBR 编码，R = N-2-P 就是有效音频数据的字节数。包里面每个音频帧的字节数量为 R/M，如下图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|0|p|     M     |  Padding length (Optional)    :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (R&#x2F;M bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (R&#x2F;M bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                              ...                              :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame M (R&#x2F;M bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 VBR 编码的情况，填充长度字节的后面跟上了 M - 1 个帧长度的编码，每个帧长度都会用一到两个字节做如前面所述的<strong>帧长度编码</strong>。其包结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|1|p|     M     | Padding length (Optional)     :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">: N1 (1-2 bytes): N2 (1-2 bytes):     ...       :     N[M-1]    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                              ...                              :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                     Compressed frame M...                     :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从上面 0 ~ 3 号包的结构可以看到，虽然有帧长度编码信息区分出包内的每个帧，但是包没有编码自己的总长度信息，因此如果编码器输出的多个包直接拼接存储在一起，那么没有办法区分出每个包的边界，编码器也就没有办法解码这种裸的编码流。为了让解码器能够处理 Opus 裸流，需要将其封装在一种容器格式中（例如 Ogg 格式），让容器格式提供分包的信息。</p><h3 id="合法音频包的验证条件">合法音频包的验证条件</h3><p>根据前面描述，我们可以通过以下几个约束条件来判断一个 Opus 包是否合法：</p><ol type="1"><li>音频包至少包含一个字节，即 TOC 字节。</li><li>一个音频帧的长度不能超过 1275 字节。</li><li>1 号音频包的字节数必须是奇数，使得 <code>(N-1)/2</code> 计算出来是整数。</li><li>2 号音频包的 TOC 字节后面必须有足够的字节数用于编码帧长度，而且帧长度不能大于音频包剩下的字节数。</li><li>3 号音频包至少包含一个音频帧，但是总的音频长度不得超过 120ms。</li><li>CBR 的 3 号包至少包含 2 个字节。添加在音频包后面的填充字节数和表示填充长度的字节数之和 P 不能大于 N-2，而且 (N-2-P) 是帧个数 M 的倍数。</li><li>VBR 的 3 号包必须足够大到容纳所有的包头字节，以及对应的前 M-1 个帧的长度，和填充字节数。</li></ol><h2 id="自划界的音频包">自划界的音频包</h2><p>如前所述，Opus 包与包之间没有界限，需要额外的机制告诉解码器每个包的大小。不过除此之外，Opus 标准还定义了一种<strong>自划界</strong>（Self-Delimiting）的音频包，编码器拿到这种包可以直接推断出包的大小。</p><p>从前面描述的 0 ~ 3 号包结构来看，对于包含 CBR 的包，由于每个帧长度一样，只需要再添加一个帧的长度编码就可以确定这个包的总大小；对于 VBR 的包，由于包里面已经含有了除最后一个帧的长度编码，只需要再添加最后一帧的长度编码就可以算出包的总大小。不管哪种情况，这个长度编码都采用前面提到的 1 ~ 2 字节的<strong>帧长度编码</strong>。下面分别描述 0 ~ 3 号包是如何添加这个长度编码的。</p><p>对于 0 号包，在 TOC 字节后面，添加帧长度编码，表示后面这个帧的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|0| N1 (1-2 bytes):                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">:                                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 1 号包，在 TOC 字节后面，添加帧长度编码，表示后面每个帧的大小。如果这个编码的值为 N1，那么后面两个帧的总大小为 2 * N1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|1| N1 (1-2 bytes):                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|               Compressed frame 2 (N1 bytes)...                |</span><br><span class="line">:                                               +-+-+-+-+-+-+-+-+</span><br><span class="line">|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 2 号包，在第一帧数据前面，添加第二帧的长度编码，表示第二帧的大小。如果这个编码的值为 N1，那么后面两个帧的总大小为 2 * N1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|0| N1 (1-2 bytes): N2 (1-2 bytes):               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               :</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">:                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 CBR 的 3 号包，在第一帧前面，添加帧长度编码，表示后面每个帧的大小。如果这个编码的值为 N1，那么后面 M 个帧的总大小为 M * N1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|0|p|     M     | Pad len (Opt) : N1 (1-2 bytes):</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                              ...                              :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame M (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 VBR 的 3 号包，在第一帧前面，添加帧长度编码，表示最后一个帧的大小。如果这个编码的值为 N[M]，那么后面 M 个帧的总大小为 N1 + N2 + ... + N[M]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|1|p|     M     | Padding length (Optional)     :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">: N1 (1-2 bytes):     ...       :     N[M-1]    |     N[M]      :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                              ...                              :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:              Compressed frame M (N[M] bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从上面的描述我们可以看到，实际上这个额外的帧长度编码都是在原来的包结构基础上，插入到了第一帧数据的前面。</p><p>在一些场景下，自划界包有实际的用途。根据标准，Opus 只能编码单声道或者双声道立体声音频。因此一个 Opus 码流要不就是单声道的，要不就是双声道的。如果要传输或者存储多声道（大于2）的音频，就需要复合多个 Opus 流。例如 5.1 环绕立体声有 6 个声道，传输或者存储这样一个音频，可能需要组合多个单声道或双声道的 Opus 流。</p><p>假如 5.1 环绕立体声由 2 个双声道，2 个单声道的 Opus 流组成。那么需要将这 4 个 Opus 流复合成一个流，每次从 4 个 Opus 流中各取一个包，组成一个复合音频包。每个复合音频包就包含四个包，分别来自同一时刻不同的 Opus 流。为了让解码器能够顺利从复合音频包中识别出四个包，就需要让前三个包采用自划界格式的编码。一般来说复合包的总大小会通过容器格式或者传输协议信息告诉解码器，因此复合包里面最后一个子 Opus 包不需要采用自划界包格式，可以直接推断出来。</p><p><strong>参考文献：</strong></p><p>[1] Voice frequency: https://en.wikipedia.org/wiki/Voice_frequency<br />[2] CELT: https://en.wikipedia.org/wiki/CELT<br />[3] Definition of the Opus Audio Codec: https://tools.ietf.org/html/rfc6716<br />[4] 5.1 surround sound: https://en.wikipedia.org/wiki/5.1_surround_sound</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;音频编码是将原始的音频采样数据，通过某种算法将其压缩编码成规定格式的二进制码流，从而方便存储和传输。Opus 就是由 &lt;a href=&quot;https://xiph.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xiph.Org&lt;/a&gt; 基金会发明的一种音频编码格式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Audio Tech" scheme="http://chenleon.me/categories/Audio-Tech/"/>
    
    
      <category term="Opus" scheme="http://chenleon.me/tags/Opus/"/>
    
  </entry>
  
  <entry>
    <title>Ogg容器格式</title>
    <link href="http://chenleon.me/2020/03/14/ogg-container-format/"/>
    <id>http://chenleon.me/2020/03/14/ogg-container-format/</id>
    <published>2020-03-14T22:34:12.000Z</published>
    <updated>2020-03-29T07:33:12.513Z</updated>
    
    <content type="html"><![CDATA[<p>Ogg是<a href="https://xiph.org/" target="_blank" rel="noopener">Xiph.Org</a>基金会推出的一种开源免费的多媒体容器格式。Ogg容器格式可以用于封装音频、视频、字幕、以及多媒体元信息。它既适用于流媒体传输，又能作为文件格式存储多媒体。</p><a id="more"></a><blockquote><p>容器格式和编码格式有区别。编码指的是将原始多媒体数据按照规定的算法将原始数据进行压缩编码，使其占用的空间更小，方便传输和存储。这个压缩编码的算法就叫做编码格式，例如视频的编码格式有：H.264、H.265（又叫做HEVC）、Theora等等，音频的编码格式有：Vorbis、ACC、FLAC、Opus等等。实现这些压缩编码算法的软件叫做编码器。而容器格式是用来封装编码之后的数据，容器格式提供了分包机制和元信息可以帮助解码器解码，而且容器可以将多种不同的编码数据复合在一起，例如视频、音频、字幕可以封装到一个容器格式里面。常用的容器格式有：MKV、MP4、AVI等等，Ogg也是容器格式一种。</p></blockquote><h2 id="ogg-二进制流">1. Ogg 二进制流</h2><p>多媒体编码器输出的是一串二进制包（Packet），包通常是解码器解码的最小单位。这些包之间通常没有分割标志，如果直接把这些包拼接在一起形成一个二进制流，那么没有任何解码器可以读出其中的包并进行解码，因为解码器将找不到每个包从哪里开始，从哪里结束。</p><p><img src="/images/ogg_container_format/1.png" style="width: 100%; max-width: 500px"/></p><p>Ogg容器格式将多媒体编码器产生的二进制包进行封装，并且提供分割信息，这样解码器就可以通过读取Ogg格式的封装信息，将二进制包一个一个拆出来进行解码。</p><p>我们将编码器生成的二进制流称为<strong>逻辑流</strong>（Logical Bitstream），把Ogg封装之后二进制流称为<strong>物理流</strong>（Physical Bitstream）。之所以这么称呼是因为编码生成的裸二进制流实际上无法被任何工具处理，只能存在于逻辑概念，而 Ogg 封装过后的流却是可以被实际操作处理的。</p><p><img src="/images/ogg_container_format/2.png" style="width: 100%; max-width: 500px"/></p><p>Ogg物理流的基本组成单位是 <strong>Ogg 页</strong>（Ogg Page）。编码器输出的二进制包就是按照Ogg格式的规则放到Ogg页中的。Ogg的规范十分灵活，一个Ogg页可以存放一个包、多个包、甚至是一包的一部分。正因为Ogg格式对编码器输出的包大小没有要求，使得Ogg格式可以用于多种视频、音频编码格式的封装。</p><p>一个Ogg物理流中可以包含多个逻辑流，例如一个Ogg文件中包含了视频、音频以及字幕三个逻辑流。如果一个Ogg流只有一个逻辑流，那么它称为一个<strong>基础流</strong> （Elementary Bitstream），如果包含多个逻辑流，那么它称为<strong>复合流</strong>（Multiplexed Bitstream）。</p><p>多个基础流通过Ogg页交错的方式组合成一个复合流，也就是将不同基础流中同样时间点的Ogg页放到一起。</p><p><img src="/images/ogg_container_format/3.png" style="width: 100%; max-width: 500px"/></p><h2 id="ogg-页的格式">2. Ogg 页的格式</h2><p>Ogg页是Ogg物理流的基本单位。一个Ogg页由头和负载两部分组成，并且总是由<code>OggS</code>四个字节开头，这四个字节称为捕获标志（Capture Pattern）。当客户端解码器从中途开始接收服务端推送的流媒体比特流时，搜索到比特流中的第一个<code>OggS</code>标志，就可以从这里开始进行比特流的解码。</p><p>Ogg页头部格式如下图所示：</p><p><img src="/images/ogg_container_format/4.png" style="width: 100%; max-width: 400px"/></p><h3 id="捕获标志capture">2.1 捕获标志（Capture）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 0   0x4f  &#39;O&#39;</span><br><span class="line"> 1   0x67  &#39;g&#39;</span><br><span class="line"> 2   0x67  &#39;g&#39;</span><br><span class="line"> 3   0x53  &#39;S&#39;</span><br></pre></td></tr></table></figure><p>固定值<code>OggS</code>。</p><h3 id="版本号version">2.2 版本号（Version）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 4   0x00</span><br></pre></td></tr></table></figure><p>Ogg格式的版本号，目前固定为0。</p><h3 id="头类型标志header-type">2.3 头类型标志（Header Type）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 5   bitflags: 0x01: 置0 &#x3D; 从新的包开始</span><br><span class="line">                     置1 &#x3D; 这个页里面的包接着上一个页里面的包</span><br><span class="line">               0x02: 置0 &#x3D; 不是逻辑流的第一个Ogg页</span><br><span class="line">                     置1 &#x3D; 逻辑流的第一个Ogg页（bos）</span><br><span class="line">               0x04: 置0 &#x3D; 不是逻辑流的最后一个Ogg页</span><br><span class="line">                     置1 &#x3D; 逻辑流的最后一个Ogg页（eos）</span><br></pre></td></tr></table></figure><p>占一个字节，根据最低的三个比特位是否设置为1表示不同的信息。</p><p>这里特别说明一下最低位<code>0x01</code>的意义，当一个包太大，导致一个Ogg页放不下，或者Ogg页已经放了很多个包，剩下的位置不够再放一个包，那么一个包就可能横跨两个连续的Ogg页。这个包开头的部分在第一页，后半部分在第二页。这种情况下，第二页的头类型标志的最低位就会置为1。</p><h3 id="位置数granule-position">2.4 位置数（Granule Position）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 6   0xXX LSB</span><br><span class="line"> 7   0xXX</span><br><span class="line"> 8   0xXX</span><br><span class="line"> 9   0xXX</span><br><span class="line">10   0xXX</span><br><span class="line">11   0xXX</span><br><span class="line">12   0xXX</span><br><span class="line">13   0xXX MSB</span><br></pre></td></tr></table></figure><p>从上面的字节序可以看出位置数采用小端字节序，这也是Ogg的默认字节序。</p><p>每个Ogg页上的位置数表示从这个逻辑流开始，到这个Ogg页上最后一个完结的包所包含的样本数。如果一个包只有开头或中间的一部分在这个Ogg页里面，那么这部分的包含的样本数不计算在位置数里面。</p><p>如果这个值为<code>-1</code>（以补码表示），那么说明这个页里面没有任何完结的包。</p><p>下面用一个例子来说明位置数。一个逻辑流由6个包组成，这个包按照下图的方式封装在4个Ogg页里面形成一个Ogg物理流。<br />- Ogg页1里面包2是这个页里面最后一个完结的包，从开头的包1开始算起，到这个包2一共有40个样本，因此Ogg页1的位置数为40。<br />- Ogg页2里面没有任何一个包是在该页结束的，因此位置数为-1。<br />- Ogg页3里面最后一个完结的包是包4，从开始到包4结尾一共有120个样本数，因此Ogg页3的位置数为120。<br />- Ogg页4里面最后一个完结的包是包6，从开始到包6结尾一共有160个样本数，因此Ogg页4的位置数为160。</p><p><img src="/images/ogg_container_format/5.png" style="width: 100%; max-width: 600px"/></p><p>对于不同类型的多媒体和编解码器，位置数的含义不一样，例如对于视频来说，它表示帧数，对于音频来说，它表示采样数。</p><h3 id="逻辑流编号bitstream-serial-number">2.5 逻辑流编号（Bitstream Serial Number）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">14   0xXX LSB</span><br><span class="line">15   0xXX</span><br><span class="line">16   0xXX</span><br><span class="line">17   0xXX MSB</span><br></pre></td></tr></table></figure><p>当多个逻辑流复合在一个Ogg物理流里面时，每个逻辑流都会有一个独特的编号，其对应的Ogg页都打上对应编号，用于区分这个Ogg页属于哪一个逻辑流。</p><h3 id="页序列号page-sequence-no">2.6 页序列号（Page Sequence No）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">18   0xXX LSB</span><br><span class="line">19   0xXX</span><br><span class="line">20   0xXX</span><br><span class="line">21   0xXX MSB</span><br></pre></td></tr></table></figure><p>Ogg流里面每个Ogg页都有一个按顺序增长的序号，这样如果在传输的时候有一页丢失了，解码器可以通过检查序号很快发现丢失的页。</p><p>如果一个Ogg物理流里面有多个逻辑流，那么每个逻辑流的Ogg页序列号是独立增长的。</p><h3 id="校验和checksum">2.7 校验和（Checksum）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">22   0xXX LSB</span><br><span class="line">23   0xXX</span><br><span class="line">24   0xXX</span><br><span class="line">25   0xXX MSB</span><br></pre></td></tr></table></figure><p>当前整个Ogg页的CRC校验和，计算包括头部数据，只是在计算前将校验和字段的四个字节置为0，计算后将得到的值再设置进去。</p><p>计算时，初始值和最后的XOR值为0，generator polynomial 为 0x04c11db7。</p><h3 id="分段个数page-segments分段表segment-table">2.8 分段个数（Page Segments）、分段表（Segment Table）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">26   0x00-0xff (0-255)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">27   0x00-0xff (0-255)</span><br><span class="line">[...]</span><br><span class="line">n    0x00-0xff (0-255, n&#x3D;page_segments+26)</span><br></pre></td></tr></table></figure><p>Ogg格式规定将一个包看成由多个大小为255字节的分段和最后一个可能小于255字节分段组成。例如一个包的大小为702字节，那么可以看是由三个分段组成大小分别为：255、255、192。如果将这个包封装到Ogg页中，那么Ogg头里面的<strong>分段个数</strong>值为3，<strong>分段表</strong>将有三个字节，值分别为：255、255、192。</p><p><strong>分段个数</strong>占一个字节，表示这个Ogg页里面有多少个包的分段。<strong>分段表</strong>的大小由<strong>分段个数</strong>决定，其中每个字节的值代表了对应分段的大小。</p><p>这个分段机制为解码器提供了区分包边界的方法，如果分段表中一个值小于255，那么代表这个包已经结束了，下一个分段就代表一个新的包开始。</p><p>用一个例子来说明这个机制，下图有三个包存储在了两个Ogg页中。</p><p><img src="/images/ogg_container_format/6.png" style="width: 100%; max-width: 350px"/></p><ul><li>包1大小为702字节，可以分成三个段：255、255、192。</li><li>包2大小为574字节，可以分成三个段：255、255、64。</li><li>包3大小为638字节，可以分成三个段：255、255、128。</li></ul><p>Ogg页1包含整个包1和包2的前两个分段，因此Ogg页1头里面的分段个数字段的值为5，分段表有5个字节，5个字节的值分别为：255、255、192、255、255。当解码器读到分段表中192这个数时，就知道这个包已经结束，可以开始解码包1的数据了。</p><p>Ogg页2包含整个包3和包2的最后一个分段，因此Ogg页2头里面的分段个数字段的值为4，分段表有4个字节，4个字节的值分别为：64、255、255、128。并且由于Ogg页2开头的数据是接着上一个Ogg页的，因此它头类型标志最低位将会设置为1。</p><p>有种特殊情况，如果一个包大小恰好为255的倍数，例如包大小为510，如果按照上面的分段方法，那么应该分成两段：255、255。但是这样依赖，解码器在分段表里面读到第二个255，并不能判断这个包是不是结束了。为了解决这个问题，Ogg规定在分段表里面插入一个0值，也就是说这个包可以看成分成三个段：255、255、0。解码器读到这个0的时候就知道这个包结束了。这个0值只存在于分段表中，不会真的在负载的包中插入数据。</p><p>从上面的分析可以看出Ogg格式对包的分段只是逻辑上的，只是用于计算分段个数和分段表中的值，并不会在负载中的包里面插入任何分隔符。</p><p>由于分段个数只占一个字节，它的最大值为255，分段表中每个分段值也只占一个字节，对应的分段大小最大为255字节。因此一个Ogg页的最大有效负载为 255 * 255 = 65025 字节，这种情况下，Ogg页的头大小为 ：27（固定大小） + 255（分段表大小） = 282 字节。整个Ogg页最大的长度为 65025 + 282 = 65307。</p><p>这个逻辑上的分段机制可以看出，虽然Ogg页的大小有限制，但是对于多媒体编码器输出的包大小没有限制，大于65025字节的包可以分开在多个连续的Ogg页里面存储，分段机制保证了解码器可以识别到包的开始和结尾。</p><h2 id="ogg-媒体类型定义">3. Ogg 媒体类型定义</h2><p>针对Ogg格式，Xiph.Org在IANA注册了三种MIME类型。分别是：</p><ul><li>application/ogg</li><li>video/ogg</li><li>audio/ogg</li></ul><p>在标准制定的早期，Ogg专门用来封装Vorbis编码格式的语音，并且在<a href="https://tools.ietf.org/html/rfc3534" target="_blank" rel="noopener">RFC3534</a>中定义了<code>application/ogg</code>类型来指代封装在Ogg格式中的Vorbis语音。不过随着技术的发展，Ogg被单独提出来作为一种可以封装任意媒体类型的容器格式。于是<a href="https://tools.ietf.org/html/rfc3534" target="_blank" rel="noopener">RFC3534</a>草案被废弃，在新的草案<a href="https://tools.ietf.org/html/rfc5334" target="_blank" rel="noopener">RFC5334</a>中重新定义了<code>application/ogg</code>的意义，并且定义了<code>video/ogg</code>和<code>audio/ogg</code>两种新的类型。</p><p><strong>video/ogg</strong></p><p>当一个Ogg流的主要信息是视频（可能包括音频和字幕），那么传输的时候应当使用<code>video/ogg</code>类型。存储成文件时应当使用<code>.ogv</code>扩展名。</p><p><strong>audio/ogg</strong></p><p>当一个Ogg流的主要信息是音频（可能包括字幕），那么传输的时候应当使用<code>audio/ogg</code>类型。存储成文件时应当使用<code>.oga</code>扩展名。</p><p>因为历史原因，Ogg格式的音频数据存储成文件时，也可以使用<code>.ogg</code>和<code>.spx</code>扩展名。<code>.ogg</code>表示音频编码格式是Vorbis；<code>.spx</code>表示音频编码格式是Speex。</p><p><strong>application/ogg</strong></p><p>当一个Ogg流非常复杂，不是单纯的视频或者音频，例如传输多路视频信号，这种情况下就建议使用<code>application/ogg</code>类型。存储文件使用<code>.ogx</code>扩展名。</p><p>对于这些MIME类型，还可以指定<code>codec</code>参数来表示Ogg流中的数据编码格式。例如传输Opus格式语音就可以使用：<code>audio/ogg; codecs=opus</code>。目前支持的codec可以参考https://wiki.xiph.org/index.php/MIMETypesCodecs。</p><hr /><p><strong>参考文献：</strong><br />[1] Ogg bitstream overview: https://www.xiph.org/ogg/doc/oggstream.html<br />[2] Ogg logical bitstream framing: https://www.xiph.org/ogg/doc/framing.html<br />[3] Ogg: https://en.wikipedia.org/wiki/Ogg<br />[4] Ogg Media Types: https://tools.ietf.org/html/rfc5334<br />[5] Specification of MIME types and respective codecs parameter: https://wiki.xiph.org/index.php/MIMETypesCodecs<br />[6] The application/ogg Media Type: https://tools.ietf.org/html/rfc3534<br />[7] The Ogg Encapsulation Format Version 0: https://tools.ietf.org/html/rfc3533</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ogg是&lt;a href=&quot;https://xiph.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xiph.Org&lt;/a&gt;基金会推出的一种开源免费的多媒体容器格式。Ogg容器格式可以用于封装音频、视频、字幕、以及多媒体元信息。它既适用于流媒体传输，又能作为文件格式存储多媒体。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Audio Tech" scheme="http://chenleon.me/categories/Audio-Tech/"/>
    
    
      <category term="Ogg" scheme="http://chenleon.me/tags/Ogg/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础知识</title>
    <link href="http://chenleon.me/2018/10/12/docker-basics/"/>
    <id>http://chenleon.me/2018/10/12/docker-basics/</id>
    <published>2018-10-12T11:22:09.000Z</published>
    <updated>2020-03-29T07:33:12.513Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是目前最流行的容器技术，它将开发和运维带入了一个新的时代。本文主要介绍 Docker 的一些基本概念和常用命令。</p><a id="more"></a><h3 id="image">Image</h3><p>Image (镜像) 是一个不可变的文件。它好比是一个可执行程序文件，操作系统执行程序时，将程序文件加载到内存执行，成为系统中的一个进程。而 Docker 通过<code>docker run</code>命令加载镜像文件执行，成为 Docker Container (容器)。</p><p>开发者编写 Dockerfile 文件，然后使用<code>docker build</code>命令来创建镜像。开发者可以将自己的镜像通过<code>docker push</code>上传到 Docker Registry 上，分享给其他人使用。其他人通过<code>docker pull</code>拉取镜像。官方的 Docker Registry 是 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，也可以自己搭建私有的 Registry。</p><p>Docker Registry 就和 GitHub 一样，是大家共享 Docker Image 的地方。其管理方式也是建立 repository (仓库)，每个仓库里面放一个镜像，随着开发的不断进行，仓库里面的镜像会有多个版本，在 Docker Registry 里面“版本”也称作 Tag (标签)。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 helloworld 的镜像，"."代表在当前目录，里面要有 Dockerfile 文件</span></span><br><span class="line">docker build -t helloworld .  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前系统中的所有镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录 Docker Hub</span></span><br><span class="line">docker login </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了将本地镜像上传到 Docker Registry，要先按照规则给本地镜像加 tag</span></span><br><span class="line"><span class="comment">#   &lt;image&gt; 是本地镜像的名字</span></span><br><span class="line"><span class="comment">#   &lt;username&gt; 是在 Docker Registry 上注册的 Docker ID；</span></span><br><span class="line"><span class="comment">#   &lt;repository&gt; 是 Docker Registry 上的仓库的名称</span></span><br><span class="line"><span class="comment">#   &lt;tag&gt; 用来区分这个镜像的不同版本</span></span><br><span class="line">docker tag &lt;image&gt; &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传镜像到 Docker Register</span></span><br><span class="line">docker push &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 Docker Register 下载镜像到本地</span></span><br><span class="line">docker pull &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p><h3 id="container">Container</h3><p>Container (容器) 就是执行中的镜像。之所以叫容器，是因为 Container 使用隔离技术，像“容器”一样，把容器中的文件和执行的进程与宿主系统隔离开来。虽然是与宿主机隔离的，进程还是执行在宿主机系统本地的。这与传统的一样虚拟机（VM）技术不一样，它的进程是执行在虚拟的操作系统中的，与宿主操作系统没关系。</p><figure><img src="/images/docker_basics_vm_and_docker_compare.png" alt="" /><figcaption>VM vs. Docker</figcaption></figure><p>Container 这种“软”隔离得益于 Linux 内核的 namespace 技术，因此 Docker 只适用于 Linux 系统。使用 namespace 技术，意味着容器中的进程还是在宿主机的内核中执行，但是因为命名空间(namespace)和其它进程不同，因此它只能看到自己所属容器中的资源。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载镜像 helloworld 到容器中运行，将容器中的 80 端口，映射到宿主系统的 4000 端口</span></span><br><span class="line">docker run -p 4000:80 helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同上，-d 选项使容器在后台执行</span></span><br><span class="line">docker run -d -p 4000:80 helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有运行中的 Container </span></span><br><span class="line">docker container ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 Container，包括没有处于运行状态的 </span></span><br><span class="line">docker container ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常停止 Container </span></span><br><span class="line">docker container stop &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制停止 Container </span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Container </span></span><br><span class="line">docker container rm &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有不是运行状态的 Container </span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure></p><h3 id="swarm">Swarm</h3><p>Swarm 是多个运行 Docker 的主机组成的集群。集群中的主机又叫做 node (节点)，根据角色分为两类：Mananger 和 Worker。Mananger 通过 <code>docker swarm init</code>命令创建，负责管理整个集群的节点，在集群中执行 Docker 指令都是在 Manager 上执行的。Worker 通过 <code>docker swarm join</code>命令加入到集群中，Worker 负责执行任务，运行 Container。通过<code>docker stack</code>命令，可以将应用按照指定的方式部署在集群上。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Docker Swarm 集群，并且让本机成为这个 Swarm 集群的 Manager</span></span><br><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让主机作为 Worker 加入到 Swarm</span></span><br><span class="line"><span class="comment">#   &lt;token&gt; 是创建 Swarm 的时候生成的认证 token，</span></span><br><span class="line"><span class="comment">#   &lt;ip&gt;:&lt;port&gt; 是 Manager 的地址</span></span><br><span class="line">docker swarm join --token &lt;token&gt; &lt;ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 join token，需要在 Manager 主机上执行</span></span><br><span class="line">docker swarm join-token -q worker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个 Swarm 可以有多个 Manager，让主机作为 Manager 加入到 Swarm 中</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群中所有的节点</span></span><br><span class="line">docker node ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个节点的详情</span></span><br><span class="line">docker node inspect &lt;node ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Worker 主机上执行下面命令，离开集群</span></span><br><span class="line">docker swarm leave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Manager 主机上执行下面命令，离开集群，如果只有一个 Manager，那么集群会被关闭</span></span><br><span class="line">docker swarm leave -f</span><br></pre></td></tr></table></figure></p><h3 id="service">Service</h3><p>Service 是运行同一个镜像的一组 Container，这些 Container 提供相同的服务。这是为了在产品环境中，让一个服务有多个运行实例做负载均衡，达到服务高可用的目的。Docker Service 是 Docker Swarm 中的概念，只能在 Swarm 中使用。</p><p>一个 Service 一般定义了需要使用什么端口、启动几个 Container、负载均衡的规则等等。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的 Service</span></span><br><span class="line">docker service ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出某个 service 下面的所有 Container</span></span><br><span class="line">docker service ps &lt;service name&gt;</span><br></pre></td></tr></table></figure></p><h3 id="stack">Stack</h3><p>Stack 是在集群中由多个 Service 组成的完整应用。一个应用通常分为多个服务，例如一个前后端分离的网站，可能分为前端页面、后端API、数据库三个服务。在集群中部署的时候，我们需要定义这三个 Service，将三个 Service 的规则写到<code>docker-cloud.yml</code>，然后使用<code>docker stack</code>命令部署到集群中去。</p><p>Stack 的前身是 <strong>docker-compose</strong>，docker-compose 是以前用来启动多个 Container 的，它使用<code>docker-compose.yml</code>文件指定多个 Container 的执行规则。Docker Stack 现在替代了 Docker Compose 的功能，而且更强大，同时 Stack 也兼容<code>docker-compose.yml</code>文件。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署应用到 Swarm，docker-cloud.yml 文件描述了 Stack 所有的 Service。</span></span><br><span class="line">docker stack deploy -c docker-cloud.yml &lt;app name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的 stack</span></span><br><span class="line">docker stack ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个 Stack</span></span><br><span class="line">docker stack rm &lt;app name&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是目前最流行的容器技术，它将开发和运维带入了一个新的时代。本文主要介绍 Docker 的一些基本概念和常用命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://chenleon.me/categories/DevOps/"/>
    
    
      <category term="AWS" scheme="http://chenleon.me/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS VPC简介以及EC2的IPv6配置</title>
    <link href="http://chenleon.me/2017/09/14/aws-vpc/"/>
    <id>http://chenleon.me/2017/09/14/aws-vpc/</id>
    <published>2017-09-14T22:11:54.000Z</published>
    <updated>2020-03-29T07:33:12.513Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon VPC (Virtual Private Cloud) 是AWS的网络基础设施。使用VPC服务可以在AWS中创建一个独立隔离的网络，在这个隔离的网络空间中可以创建任何AWS资源，例如EC2、Redis、RDS数据库等等，VPC网络使这些AWS资源互相连接，传递数据，并且提供外网访问的网关。</p><p>实际上很多人可能不知道，如果你已经在使用AWS的EC2，你就已经在不知不觉中使用了VPC。当我们最开始使用AWS服务时，AWS为我们创建了一个默认的VPC网络，我们创建的EC2实例（如果不手动选择）都默认加入到了这个VPC网络中。EC2、RDS等资源必须创建在一个VPC网路中，才能互相联通，访问网络。</p><a id="more"></a><figure><img src="/images/default_vpc.png" alt="" /><figcaption>Default VPC</figcaption></figure><p>除了默认的VPC，我们也可以自己创建VPC网络。VPC同时支持IPv4和IPv6组网，一个VPC网络由多个部分组成。</p><h3 id="vpc和子网subnet">VPC和子网(Subnet)</h3><p>当新建一个VPC，需要为虚拟网络定义IP地址范围作为CIDR地址，例如CIDR为<code>10.1.0.0/16</code>。IPv4的CIDR可以手动指定，但是IPv6的CIDR只能由AWS自动分配。</p><blockquote><p>CIDR（无类别域间路由，Classless Inter-Domain Routing）将IP地址按照前缀分成一组，使用一种无类别的域际路由选择算法，大大减少了路由表维护的条目数。</p></blockquote><p>VPC的IP地址段可以进一步划分IP段，从而创建子网(Subnet)。一个VPC横跨多个可用区(Availability Zone)，但是一个子网只能位于一个可用区里面。</p><p>创建EC2、RDS等AWS资源的时候，除了要选择VPC，还要选择创建到VPC的哪个子网里面。EC2会被自动分配一个所属子网IP段内的私有IP地址，如果想要分配公网IP地址，需要手动指定弹性IP，或者可以配置子网自动为EC2分配公网IP地址。如果想要让EC2被外网访问到，除了需要配置公网IP地址，还需要配置子网的路由表，使其可以通过VPC网关(Internet Gateway)访问外网。</p><p>Subnet是一个VPC里面一个IP段. 创建任何AWS资源的时候可以选择一个Subnet。</p><p>AWS 以前没有VPC，而是叫做EC2-Classic的网络。2013年之后就支持EC2-VPC了。 对于只支持VPC的新账户，会有一个Default VPC，并且在每个Availability Zone里面都有一个默认的Default Subnet，新账号就默认使用个VPC，而不用自己选择。当然也可以自己创建VPC。</p><p>Default VPC 里面默认配置了网关(Internet Gateway)，而且配置好了到网关的路由，每个Default Subnet里面的EC2都默认分配私有IP和公网IP。因此Default Subnet里面的EC2都是可以外网访问的。</p><h3 id="internet-gateway和route-table">Internet Gateway和Route Table</h3><p>VPC是一个独立的虚拟的网络，与AWS其它的VPC、与外网都是隔离开得。如果想要让外网访问VPC里面的EC2，必须通过网关（Internet Gateway）。网关是VPC连接外网的组件，可以为VPC分配多个网关，每个网关都有唯一的ID，例如<code>igw-8727e8e2</code>。配置路由表的时候，网关ID作为路由表的目标地址（target）。</p><blockquote><p>如果只想让instance主动访问外网，不想让外网主动访问instance。IPv4可以使用<strong>NAT</strong>，IPv6可以使用<strong>Egress-Only Internet Gateways</strong>。</p></blockquote><p>VPC里面的Subnet都关联了一张路由表(Route Table)，路由表定义了VPC网络里面的网络流量的传输路径。</p><p>每个VPC创建之后都自动配置了一个路由表，这种关联在VPC上的路由表叫做主路由表(Main Route Table)。主路由表不能删除，但是可以替换为别的路由表。 每个Subnet创建之后默认使用主路由表，但是可以为Subnet创建一个自定义路由表(Custom Route Table)来设置特定路由规则。自定义路由表可以删除，删除之后就使用VPC的主路由表。</p><p>e.g. 一个使用主路由表的例子<br /><img src="/images/aws_vpc_subnets.png" alt="Default VPC" /></p><p>在上面这个例子中，VPC的网段为<code>10.1.0.0/16</code>，里面有两个子网：<code>10.1.1.0/24</code>和<code>10.1.2.0/24</code>。这两个子网没有自定义路由表，因此都使用VPC的主路由表。</p><p>主路由表中有两条路由规则：<br />- destination为<code>10.1.0.0/16</code>表示VPC内部的流量，因为VPC网段下的所有IP地址都是<code>10.1</code>开头。这些流量的target是<code>local</code>，表示内部之间通信。<br />- destination为<code>0.0.0.0/0</code>表示访问外网IP的流量，这些流量通过target指定ID的Internet Gateway访问外网。</p><h3 id="security-group">Security Group</h3><p>安全组（Security Group）定义了防火墙规则，包括出站规则和入站规则，可以细化到哪个IP段可以访问哪个端口。</p><h3 id="为vpc中的ec2配置ipv6">为VPC中的EC2配置IPv6</h3><p>VPC默认是使用IPv4来组网的，如果想要支持IPv6，创建VPC的时候需要手动指定CIDR IPv6地址段。对于已经创建好的IPv6 VPC，也可以添加IPv6 CIDR。</p><p>和IPv4不同的是，VPC的IPv6 CIDR前缀长度固定为<code>/56</code>。Subnet的IPv6 CIDR固定为<code>/64</code>。而且IPv6的CIDR段不能手动设置，全靠AWS自动分配。</p><blockquote><p>和 IPv4 不同的是 IPv6 地址不区分私有地址和共网地址</p></blockquote><p>要想创建的 EC2 实例添加IPv6，需要满足以下两个条件：<br />- EC2实例所属的Subnet配置了IPv6 CIDR<br />- 创建EC2实例的时候勾选上<code>Auto-assign IPv6 IP</code>设置。如果Subnet设置了<code>Enable auto-assign IPv6 address</code>选项，那么创建EC2的时候不需要再手动选择分配IPv6地址了。</p><blockquote><p>不管Instance的状态是start还是stop，Instance的IPv6地址都不会被释放。只有当Instance Terminate的时候，IPv6地址才会释放。</p></blockquote><p>让一个VPC支持IPv6需要完成一下配置：</p><ul><li>在VPC管理界面，选择想要更改的VPC，右键编辑他的<code>CIDRs</code>，在选项中添加IPv6 CIDR。AWS将自动分配一个IPv6 CIDR。</li><li>找到VPC下面的Subnet，为想要修改的Subnet分配IPv6 CIDR。</li><li>在VPC的主路由表里面添加一行路由表，destination设置为<code>::/0</code>，target为对应网关的ID。让IPv6流量通过网关访问到外网。</li></ul><p>如果想要让一个支持IPv6的Subnet里面的EC2实例支持IPv6，还需要做如下配置：</p><ul><li>在 AWS EC2 管理界面里面选择要修改的EC2实例，在Actions里面选择Manage IP Address选项可以为EC2实例添加IPv6地址。</li><li>修改实例关联的Security Group，添加IPv6地址的Inbound/Outbound规则。</li></ul><p><strong>注意</strong>：虽然在 AWS EC2 管理界面里面为实例分配了IPv6地址，但是操作系统里面未必识别到了IPv6地址。如果实例使用的是Amazon Linux 2016.09.0以后的版本，则实例会自动获得IPv6地址。但是Ubuntu/CentOS系统不能获得IPv6地址，需要在系统里面做进一步配置。</p><p>在Ubuntu 16.04系统里面执行如下命令可以马上获得分配的IPv6地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dhclient -6</span><br></pre></td></tr></table></figure><p>但是这个命令会在系统重启之后失效，为了让下次重启的时候，能够自动IPv6地址，执行下面的命令配置DHCPv6：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces.d/60-default-with-ipv6.cfg</span><br><span class="line">// 在文件中添加: iface eth0 inet6 dhcp</span><br><span class="line"> </span><br><span class="line">sudo ifdown eth0 ; sudo ifup eth0</span><br></pre></td></tr></table></figure><blockquote><p>有时候执行<code>dhclient</code>命令不工作，只能用第二种方法。</p></blockquote><p>为了让新建的Ubuntu实例也自动支持IPv6，需要将这一行加入到UserData中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"iface eth0 inet6 dhcp"</span> &gt;&gt; /etc/network/interfaces.d/60-default-with-ipv6.cfg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Amazon VPC (Virtual Private Cloud) 是AWS的网络基础设施。使用VPC服务可以在AWS中创建一个独立隔离的网络，在这个隔离的网络空间中可以创建任何AWS资源，例如EC2、Redis、RDS数据库等等，VPC网络使这些AWS资源互相连接，传递数据，并且提供外网访问的网关。&lt;/p&gt;
&lt;p&gt;实际上很多人可能不知道，如果你已经在使用AWS的EC2，你就已经在不知不觉中使用了VPC。当我们最开始使用AWS服务时，AWS为我们创建了一个默认的VPC网络，我们创建的EC2实例（如果不手动选择）都默认加入到了这个VPC网络中。EC2、RDS等资源必须创建在一个VPC网路中，才能互相联通，访问网络。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://chenleon.me/categories/DevOps/"/>
    
    
      <category term="AWS" scheme="http://chenleon.me/tags/AWS/"/>
    
  </entry>
  
</feed>
