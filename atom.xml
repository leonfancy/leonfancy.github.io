<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈亮的个人博客</title>
  
  <subtitle>Coding Fantasy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenliang.org/"/>
  <updated>2020-07-12T03:47:32.298Z</updated>
  <id>http://chenliang.org/</id>
  
  <author>
    <name>Leon Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ogg 封装 Opus 音频流</title>
    <link href="http://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/"/>
    <id>http://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/</id>
    <published>2020-04-17T22:46:22.000Z</published>
    <updated>2020-07-12T03:47:32.298Z</updated>
    
    <content type="html"><![CDATA[<p>Opus 编码后的音频流不方便存储和传输，Ogg 作为一种容器格式，提供了封装 Opus 音频流的方法。封装之后音频流方便存储和传输，并且提供了一些关键特性，包括元数据，快速而精准的定点播放，封装只需要很少额外数据开销，而且方便与其它的数据流（例如视频）复合。</p><a id="more"></a><h2 id="ogg-封装-opus-流的包结构"><a href="#ogg-封装-opus-流的包结构" class="headerLink" title="ogg-封装-opus-流的包结构"></a>Ogg 封装 Opus 流的包结构</h2><p>Ogg 流是由一个一个 Ogg 页（Ogg Page）组成的，每个 Ogg 页封装了来自一个或者多个“数据包”的数据。“数据包”如果太大，有可能会分散到多个 Ogg 页中。“数据包”如果比较小，一个 Ogg 页也有可能包含多个数据包。“数据包”不一定是指音频数据，也有可能是元数据等等。</p><p>一个 Ogg 封装的 Opus 音频流的格式如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   Page 0         Pages 1 ... n        Pages (n+1) ...</span><br><span class="line">+------------+ +---+ +---+ ... +---+ +-----------+ +---------+ +--</span><br><span class="line">|            | |   | |   |     |   | |           | |         | |</span><br><span class="line">|+----------+| |+-----------------+| |+-------------------+ +-----</span><br><span class="line">|| ID Header|| ||  Comment Header || ||Audio Data Packet 1| | ...</span><br><span class="line">|+----------+| |+-----------------+| |+-------------------+ +-----</span><br><span class="line">|            | |   | |   |     |   | |           | |         | |</span><br><span class="line">+------------+ +---+ +---+ ... +---+ +-----------+ +---------+ +--</span><br><span class="line">^      ^                           ^</span><br><span class="line">|      |                           |</span><br><span class="line">|      |                           Mandatory Page Break</span><br><span class="line">|      ID header is contained on a single page</span><br><span class="line">'Beginning Of Stream'</span><br></pre></td></tr></table></figure><p>在这个流中，有两个数据包是必须的。第一个包是 <strong>ID 头</strong>（ID Header），这个包不是 Opus 音频包，它所携带的信息表明了这个二进制流是 Opus 音频。这个 ID 头独占第一个 Ogg 页，这一页不会包含其它数据，而且 ID 头的大小也不会超过一个 Ogg 页。第一页的 Ogg 头类型标志中的 bos 标志将会被置为 1，表示逻辑流的开始。</p><p>逻辑流中的第二个必须的包叫做<strong>注解头</strong>（Comment Header），其中包含了用户创建流时提供的元信息，例如标题、发行时间、艺术家名字等等。注解头从逻辑流的第二个 Ogg 页开始，有可能太大会占据多个页，并且它结尾的那个 Ogg 页不能包含别的包的数据。</p><p>后续的 Ogg 页都是音频数据页，里面包含<strong>音频包</strong>（Audio Data Packet）。这里要特别说明一下音频包的含义。一个音频包并不等同于一个 Opus 编码输出的 Opus 包（Opus Packet）。Opus 编码器最只可以编码单声道或者双声道立体声，所以一个 Opus 包最多包含两个声道的数据。如果要用 Opus 编码多声道环绕立体声，那么只能组合多个单声道或者双声道的 Opus 流来实现。例如一个 5.0 环绕立体声可能由 3 个 Opus 流组合而成：2 个双声道，加上一个单声道 Opus 流。</p><p>假设一个多声道音频流由 N 个 Opus 流组成，把 N 个流在同一时间点上的 N 个 Opus 包组合在一起就形成一个<strong>音频包</strong>。为了在一个音频包里面区分出 N 个 Opus 包，一个音频包里面前 （N-1）个 Opus 包采用<a href="https://tools.ietf.org/html/rfc6716#appendix-B" target="_blank" rel="noopener"><strong>带分界（Self-Delimiting）的包格式</strong></a>，最后一个包采用标准 Opus 包格式。另外需要注意的是一个音频包里面的所有 Opus 包代表的时间长度必须相同。</p><figure><img src="/images/ogg_encapsulation_for_opus/1.png" alt=""><figcaption>3 个 Opus 流组合成一个 Ogg 逻辑流，每个音频包由相同时间点上的 3 个 Opus 包组成</figcaption></figure><p>对于单声道或者双声道立体声，N 通常为 1，对于多声道音频来说 N 大于 1。N 的具体值定义在了 ID 头里面，并且在整个 Ogg 逻辑流里面保持不变。</p><blockquote><p>根据声道数，音频一般分为单声道音频（mono）、双声道立体声音频（stereo）、多声道环绕立体声音频（multichannel surround）。</p></blockquote><h2 id="位置数granule-position"><a href="#位置数granule-position" class="headerLink" title="位置数granule-position"></a>位置数（Granule Position）</h2><p>根据 Ogg 格式的标准，每个 Ogg 页的头部都有一个位置数字段。位置数至关重要，它代表当前页音频数据的播放时间点。包含 ID 头和包含注解头结尾的两个 Ogg 页的位置数为 0，这是因为这两个包不是音频，因此不占用播放时间。音频 Ogg 页的位置数是从音频流开始到当前页中最后一个完结音频包所包含的总 PCM 采样数。如果一个 Ogg 页里面没有一个完结的包，那么这个页的位置数为 -1（以补码的形式编码）。关于 Ogg 页位置数字段的详细解释，请参考<a href="https://chenliang.org/2020/03/14/ogg-container-format/">《Ogg 容器格式》</a>这篇文章。</p><p>音频 Ogg 页的位置数记录的是按照 48kHz 的采样率解码得到的 PCM 采样数。（并且是按照一个声道的采样数来计算。同样时间长度的音频，多声道的位置数并不比单声道的大）。解码器也可以按照其它采样率来解码，但是因为 Opus 编码时使用的采样率都能被 48kHz 除尽，因此一律按照 48kHz 的解码采样率来计算位置数是一种简单有效的办法。</p><p>根据 Opus 标准的规定，一个音频帧最小为 2.5ms，一个 Opus 包最多包含 48 个帧，因此一个 Opus 包的时间长度为 2.5ms 到 120ms 之间，而且长度肯定是 2.5ms 的倍数。 一个帧的时间长度被编码在了 Opus 包开头的 TOC 字节里。解码器解码一帧数据返回的 PCM 采样数一定是和这个时间长度对应的。例如一个 20ms 的帧，按照 48kHz 采样率解码后的采样个数是 960。</p><p>根据 Ogg 页上的位置数，解码器可以通过向前或者后项查询，给每个解码得到的 PCM 采样分配一个位置数编号。</p><h3 id="流开头可跳过的-pcm-采样数pre-skip"><a href="#流开头可跳过的-pcm-采样数pre-skip" class="headerLink" title="流开头可跳过的-pcm-采样数pre-skip"></a>流开头可跳过的 PCM 采样数：Pre-Skip</h3><p>由于 Opus 编码的某些原因，编码器会在音频的开头插入一些无用的 PCM 采样，解码器会解码这些采样，但是解码后会丢弃掉这些 PCM 采样，不播放它们。</p><p>Ogg 页的位置数包含了这些插入在前面的 PCM 采样数。要计算实际的 PCM 采样数，应当采取如下公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际 PCM 采样数 = 位置数 - 前置插入 PCM 采样数</span><br></pre></td></tr></table></figure><p>播放器上应当显示的播放时间为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">            实际 PCM 采样数</span><br><span class="line">播放时间 = -------------------</span><br><span class="line">               48000.0</span><br></pre></td></tr></table></figure><p>在 ID 头里面有一个<code>pre-skip</code>字段，它的值就等于编码器插入的无用 PCM 采样数。</p><h3 id="对第一个位置数的限制"><a href="#对第一个位置数的限制" class="headerLink" title="对第一个位置数的限制"></a>对第一个位置数的限制</h3><p>对于第一个包含包尾的音频 Ogg 页，其位置数有可能大于实际解码得到的 PCM 采样数。因为有可能是从实时语言流的中间开始接收音频。</p><h3 id="尾部可丢弃的采样数"><a href="#尾部可丢弃的采样数" class="headerLink" title="尾部可丢弃的采样数"></a>尾部可丢弃的采样数</h3><p>最后一个 Ogg 页，也就是设置了 eos 标志的页，它的位置数可能比实际解码出来的 PCM 采样数小。那么最后多出来的那些 PCM 采样就可以丢弃掉。</p><h2 id="id-头id-header"><a href="#id-头id-header" class="headerLink" title="id-头id-header"></a>ID 头（ID Header）</h2><p><strong>ID 头</strong>（ID Header）包含的数据至关重要，只要理解了里面每个字段的意思，就基本理解了 Ogg 是如何封装 Opus 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      'O'      |      'p'      |      'u'      |      's'      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      'H'      |      'e'      |      'a'      |      'd'      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Version = 1  | Channel Count |           Pre-skip            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     Input Sample Rate (Hz)                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|   Output Gain (Q7.8 in dB)    | Mapping Family|               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               :</span><br><span class="line">|                                                               |</span><br><span class="line">:               Optional Channel Mapping Table...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>上图是 ID 头的格式。下面详细解释每个字段的意思。</p><h3 id="魔数magic-signature"><a href="#魔数magic-signature" class="headerLink" title="魔数magic-signature"></a>魔数（Magic Signature）</h3><p>这是 8 个固定的字节，其内容为<code>OpusHead</code>。</p><h3 id="版本号version"><a href="#版本号version" class="headerLink" title="版本号version"></a>版本号（Version）</h3><p>占 1 个字节，表示版本号，目前版本号的值始终为<code>1</code>。可以把这个版本号看作两部分，高 4 位为主版本号，低 4 位为次版本号。如果主版本号不相同，那么表示两个版本的格式不兼容。</p><h3 id="输出声道数output-channel-count"><a href="#输出声道数output-channel-count" class="headerLink" title="输出声道数output-channel-count"></a>输出声道数（Output Channel Count）</h3><p>占 1 个字节，表示解码这个音频流需要输出的声道个数，我们把这个声道数记为 C。</p><p>前面我们提到过，一个 Ogg 封装的音频流可能包含 N 个 Opus 音频流。这个输出声道数 C 并不等于 N，而是可以取任意值。由于 Opus 的特性，即便是同一个 Opus 流，里面每个包所代表的声道数都可能不一样，每个 Opus 包的声道数都由其开头的 TOC 字节中的 s 标志指定，如下图所示， 0 表示单声道，1 表示双声道立体声。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s| c |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>编码的时候，编码器会根据输入的 PCM 数据，以及当前编码音频帧的特性，来决定当前编码输出到底是单声道还是双声道。解码的时候，解码一个 Opus 流到底输出一个声道还是两个声道，并不会根据 TOC 中 s 的指示的来输出，实际上因为每个包 s 取值都有可能不同，也不能根据它来解码。而是根据需求，配置解码器，让它解码成单声道或者双声道。当解码配置为单声道，而某个 Opus 包是双声道数据时，解码器会将两个声道的数据求平均合成一个声道的数据。如果解码配置为双声道，而某个 Opus 包是单声道数据时，解码器将单声道数据复制成两个声道的数据。</p><p>因为一个 Ogg 流中有 N 个 Opus 流，具体对每个 Opus 流如何解码，是根据<strong>声道映射类</strong>（Channel Mapping Family）和<strong>声道映射表</strong>（Channel Mapping Table）共同决定的。这个后面会详细解释。</p><h3 id="输入采样率input-sample-rate"><a href="#输入采样率input-sample-rate" class="headerLink" title="输入采样率input-sample-rate"></a>输入采样率（Input Sample Rate）</h3><p>占 4 个字节，以小端法表示的无符号整数。代表编码前原始输入的 PCM 采样率。但是并不代表解码后播放语言的采样率。</p><p>对于 Opus 这种有损编码来说，编码的时候并不会保留原始的采样率，在编码的时候会根据每个帧的特征决定采用哪种采样率编码。因此同一个流中每个 Opus 包应用采样率可能都不一样，每个包的采样率和对应的带宽由 TOC 字节中的 config 定义。在解码播放的时候，根据下面的实际情况，按照某种采样率解码：</p><ul><li>如果硬件支持 48 kHz，那么按照 48 kHz 解码。</li><li>如果硬件最高支持的采样率是某个 Opus 支持的采样率（8 kHz，12 kHz，16 kHz，24 kHz，48 kHz），那么按照这个支持的采样率解码。</li><li>如果硬件最高支持的采样率小于 48 kHz，那么选择一个刚好大于硬件采样率的 Opus 支持的采样率解码，解码后重采样成硬件需要的采样率。</li><li>其它情况使用 48 kHz 解码，然后重采样。</li></ul><p>当需要将 Ogg Opus 解码输出成 PCM 文件时，输出的 PCM 文件可以按照这个<strong>输入采样率</strong>来存储。这样解码输出文件保持和原始输入 PCM 一样的采样率，可以让用户不至于困惑。</p><p>由于<strong>输入采样率</strong>对解码并没有多大意义，因此它的值也可以设置为 0，表示未定义。</p><h3 id="输出增益output-gain"><a href="#输出增益output-gain" class="headerLink" title="输出增益output-gain"></a>输出增益（Output Gain）</h3><p>占 2 个字节，以小端法表示的有符号数。代表解码时，应用到每个采样的增益，单位为 dB。这个数采用 <a href="https://en.wikipedia.org/wiki/Q_(number_format)" target="_blank" rel="noopener">Q7.8</a> 格式表示，16 位中有 8 位代表小数部分，是个有符号的浮点数。假如增益倍数为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-78"></use></g></g></g></svg></mjx-container></span>，按照 dB 的定义，那么这个<strong>输出增益</strong>的值就为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.581ex" xmlns="http://www.w3.org/2000/svg" width="8.915ex" height="2.151ex" role="img" focusable="false" viewBox="0 -694 3940.4 950.9" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><use xlink:href="#MJX-TEX-N-32"></use><use xlink:href="#MJX-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="msub" transform="translate(1166.7, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-N-6C"></use><use xlink:href="#MJX-TEX-N-6F" transform="translate(278, 0)"></use><use xlink:href="#MJX-TEX-N-67" transform="translate(778, 0)"></use></g><g data-mml-node="TeXAtom" transform="translate(1278, -241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-TEX-N-31"></use><use xlink:href="#MJX-TEX-N-30" transform="translate(500, 0)"></use></g></g></g><g data-mml-node="mo" transform="translate(3201.8, 0)"><use xlink:href="#MJX-TEX-N-2061"></use></g><g data-mml-node="mi" transform="translate(3368.4, 0)"><use xlink:href="#MJX-TEX-I-78"></use></g></g></g></svg></mjx-container></span>。</p><p>假如输出增益的值为 a，解码得到某个 PCM 采样的值为 y，那么应用这个增益得到的值 p 可用如下公式计算得到：</p><p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="14.817ex" height="2.527ex" role="img" focusable="false" viewBox="0 -912.1 6549.1 1117.1" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-70"></use></g><g data-mml-node="mo" transform="translate(780.8, 0)"><use xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(1836.6, 0)"><use xlink:href="#MJX-TEX-I-79"></use></g><g data-mml-node="mo" transform="translate(2548.8, 0)"><use xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(3549, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-TEX-N-31"></use><use xlink:href="#MJX-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="mfrac" transform="translate(1000, 413) scale(0.707)"><g data-mml-node="mi" transform="translate(1191.9, 394) scale(0.707)"><use xlink:href="#MJX-TEX-I-61"></use></g><g data-mml-node="mrow" transform="translate(220, -345) scale(0.707)"><g data-mml-node="mn"><use xlink:href="#MJX-TEX-N-32"></use><use xlink:href="#MJX-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="mo" transform="translate(1000, 0)"><use xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mn" transform="translate(1778, 0)"><use xlink:href="#MJX-TEX-N-32"></use><use xlink:href="#MJX-TEX-N-35" transform="translate(500, 0)"></use><use xlink:href="#MJX-TEX-N-36" transform="translate(1000, 0)"></use></g></g><rect width="2517.9" height="60" x="120" y="220"></rect></g></g></g></g></svg></mjx-container></span></p><p>播放器应用这个增益之后会改变声音的音量。</p><h3 id="声道映射类channel-mapping-family"><a href="#声道映射类channel-mapping-family" class="headerLink" title="声道映射类channel-mapping-family"></a>声道映射类（Channel Mapping Family）</h3><p>占 1 个字节，无符号整数。定义了声道映射的类别。目前只能取值为 0、1、255。根据取值 x，我们把它称为<strong>第 x 类声道映射</strong>。其具体意思在后面解释。</p><h3 id="声道映射表channel-mapping-table"><a href="#声道映射表channel-mapping-table" class="headerLink" title="声道映射表channel-mapping-table"></a>声道映射表（Channel Mapping Table）</h3><p>占多个字节。当<strong>声道映射类</strong>不为 0 时，ID 头里面才包含这个<strong>声道映射表</strong>。其具体意思在下一节解释。</p><h2 id="声道映射channel-mapping"><a href="#声道映射channel-mapping" class="headerLink" title="声道映射channel-mapping"></a>声道映射（Channel Mapping）</h2><p>前面我们提到了，一个 Ogg 流里面封装了 N 个 Opus 流。通过声道映射表的定义，这 N 个 Opus 流可以解码出 M + N 个声道。最后根据之前<strong>输出声道数</strong>的定义可以输出 C 个声道。</p><p>除了第 0 类声道映射，在 ID 头里面都编码了如下的声道映射表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">                                                +-+-+-+-+-+-+-+-+</span><br><span class="line">                                                | Stream Count  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| Coupled Count |              Channel Mapping...               :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>第一个字节是 <strong>Opus 流个数 “N”</strong>（Stream Count），为无符号整数，表示这个 Ogg 流中封装了 N 个 Opus 流。也意味着一个音频包中包含了 N 个 Opus 包。N 不能为 0。</p><p>第二个字节是<strong>双声道 Opus 流个数 “M”</strong>（Coupled Stream Count），为无符号整数。这个数 M 必须小于等于 N，它告诉解码器每个音频包中前 M 个 Opus 包按照双声道来解码，剩下的 N - M 个 Opus 包按照单声道解码。因此解码出来的总声道数为 M + N，总声道数不能大于 255。</p><p><strong>声道映射关系</strong>（Channel Mapping）占 C 个字节。每个字节对应一个输出声道，它的值表示解码出来声道与输出声道的对应关系。这个表就相当于建立了 M + N 个解码声道与 C 个输出声道的关系。假设某个字节的值为<code>index</code>，这个值要么是小于 M + N 的，要么等于特殊值 255。假如<code>index</code>小于 <code>2*M</code>，那么解码出的第<code>index/2</code>个 Opus 流是个双声道流，如果<code>index</code>是偶数，输出声道就取这个流的左声道，如果是奇数，就取右声道。假如<code>index</code>大于 <code>2*M</code> 且小于 255，那么解码出的第<code>index - M</code>个 Opus 流是单声道的，那么输出声道就取自这个流。如果<code>index</code>等于 255，那么输出声道就是纯粹的静音。</p><figure><img src="/images/ogg_encapsulation_for_opus/2.png" alt=""><figcaption>N = 3，M = 2。表示 Ogg 流里面包含 3 个 Opus 流，每个音频包由 3 个 Opus 包组成，前 2 个 Opus 包解码成双声道，第 3 个 Opus 包解码成单声道。图中还给出了不同的 index 取值，对应于哪个 Opus 流的哪个声道</figcaption></figure><p>输出声道数 C 并不一定要等于解码声道数 M + N。相同的<code>index</code>值可能会多次出现，也就是说多个输出声道对应相同的解码声道，同时有些解码声道没有对应的输出声道。</p><p>每个声道映射类所允许的声道个数和含义都不一样，下面详细介绍各个声道映射类对应的声道含义。</p><h3 id="第-0-类声道映射"><a href="#第-0-类声道映射" class="headerLink" title="第-0-类声道映射"></a>第 0 类声道映射</h3><p>允许的声道个数：1 或者 2。表示单声道或者双声道音频。</p><p>对于第 0 类声道映射来说，ID 头里面不包含声道映射字段。它的 N 默认等于 1，表示 Ogg 流里面只封装了一个 Opus 流。C 等于 1 或者 2，表示输出单声道或者双声道，M 等于 C - 1。因此可以看出，输出声道就对应这个 Opus 流按照单声道或者双声道解码出来的 1 个声道或者 2 个声道。</p><h3 id="第-1-类声道映射"><a href="#第-1-类声道映射" class="headerLink" title="第-1-类声道映射"></a>第 1 类声道映射</h3><p>允许的声道个数为：1 到 8。每个声道对应不同的扬声器排列方式，其输出声道排列如下：</p><ul><li>1 个声道：单声道。</li><li>2 个声道：双声道立体声。声道排列：左声道，右声道。</li><li>3 个声道：线性环绕立体声。声道排列：左声道，中声道，右声道。</li><li>4 个声道：四声道环绕立体声。声道排列：左前声道，右前声道，左后声道，右后声道。</li><li>5 个声道：5.0 环绕立体声。声道排列：左前声道，中前声道，右前声道，左后声道，右后声道。</li><li>6 个声道：5.1 环绕立体声。声道排列：左前声道，中前声道，右前声道，左后声道，右后声道，低音效（LFE）声道。</li><li>7 个声道：6.1 环绕立体声。声道排列：左前声道，中前声道，右前声道，左侧声道，右侧声道，中后声道，低音效（LFE）声道。</li><li>8 个声道：7.1 环绕立体声。声道排列：左前声道，中前声道，右前声道，左侧声道，右侧声道，左后声道，右后声道，低音效（LFE）声道。</li></ul><p>这些声道的排列和含义和 Vorbis 格式是一样的，但是和 WAV 和 FLAC 格式不一样。如果需要在这些格式之间做转换，那么需要注意重新排列声道顺序。</p><h3 id="第-255-类声道映射"><a href="#第-255-类声道映射" class="headerLink" title="第-255-类声道映射"></a>第 255 类声道映射</h3><p>允许的声道个数为：1 到 255。但是每个声道没有特别的含义。播放器一般不会播放这一类音频流。某些软件的实现可以将每个声道存储成单独的 PCM 文件，但是对于<code>index</code>值为 255 的声道是不输出任何文件的，因为这代表着静音。</p><h3 id="未定义的声道映射类"><a href="#未定义的声道映射类" class="headerLink" title="未定义的声道映射类"></a>未定义的声道映射类</h3><p>声道映射类 2 到 254 是保留的类，目前没有任何特殊含义。</p><h2 id="注解头comment-header"><a href="#注解头comment-header" class="headerLink" title="注解头comment-header"></a>注解头（Comment Header）</h2><p>注解头的结构比较简单，如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      'O'      |      'p'      |      'u'      |      's'      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      'T'      |      'a'      |      'g'      |      's'      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     Vendor String Length                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                        Vendor String...                       :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   User Comment List Length                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 User Comment #0 String Length                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                   User Comment #0 String...                   :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 User Comment #1 String Length                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                                                               :</span><br></pre></td></tr></table></figure><p>注解头也是以 8 个字节的固定<strong>魔数</strong>（Magic Signature）开头，其值固定为<code>OpusTags</code>。</p><p><strong>厂商字符串长度</strong>（Vendor String Length）占 4 个字节，是小端法表示的无符号整数。它代表后面<strong>厂商字符串</strong>（Vendor String）的长度，厂商字符串不包含 null 结尾的字节。厂商字符串用于存储编解码器和封装容器的名字等相关信息。</p><p><strong>注解列表长度</strong>（User Comment List Length）占 4 个字节，是小端法表示的无符号整数。它表示后面注解的个数。其中每个注解由两部分组成，一个是<strong>注解字符串长度</strong>（User Comment String Length），另一个是<strong>注解字符串</strong>（User Comment String）。</p><p>注解字符串使用<code>NAME=value</code>的格式，注解标签名与 <a href="https://www.xiph.org/vorbis/doc/v-comment.html" target="_blank" rel="noopener">Vorbis 格式</a>中定义的一样，包含了：ARTIST、TITLE、DATE、ALBUM，等等。</p><p><strong>参考文献：</strong><br>[1] Self-Delimiting Framing: https://tools.ietf.org/html/rfc6716#appendix-B<br>[2] Ogg Vorbis I format specification: comment field and header specification: https://www.xiph.org/vorbis/doc/v-comment.html<br>[3] Ogg Encapsulation for the Opus Audio Codec: https://tools.ietf.org/html/rfc7845<br>[4] Ogg容器格式: https://chenliang.org/2020/03/14/ogg-container-format<br>[5] Opus 音频编码格式: https://chenliang.org/2020/03/15/opus-format/</p><svg style="display: none" id="MJX-SVG-global-cache"><defs><path id="MJX-TEX-I-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-TEX-N-2061" d=""></path><path id="MJX-TEX-I-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-TEX-I-79" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-TEX-I-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-TEX-N-35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path id="MJX-TEX-N-36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></defs></svg>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Opus 编码后的音频流不方便存储和传输，Ogg 作为一种容器格式，提供了封装 Opus 音频流的方法。封装之后音频流方便存储和传输，并且提供了一些关键特性，包括元数据，快速而精准的定点播放，封装只需要很少额外数据开销，而且方便与其它的数据流（例如视频）复合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Audio Tech" scheme="http://chenliang.org/categories/Audio-Tech/"/>
    
    
      <category term="Ogg" scheme="http://chenliang.org/tags/Ogg/"/>
    
      <category term="Opus" scheme="http://chenliang.org/tags/Opus/"/>
    
  </entry>
  
  <entry>
    <title>Opus 音频编码格式</title>
    <link href="http://chenliang.org/2020/03/15/opus-format/"/>
    <id>http://chenliang.org/2020/03/15/opus-format/</id>
    <published>2020-03-15T21:43:33.000Z</published>
    <updated>2020-07-12T03:47:32.298Z</updated>
    
    <content type="html"><![CDATA[<p>音频编码是将原始的音频采样数据，通过某种算法将其压缩编码成规定格式的二进制码流，从而方便存储和传输。Opus 就是由 <a href="https://xiph.org/" target="_blank" rel="noopener">Xiph.Org</a> 基金会发明的一种音频编码格式。</p><a id="more"></a><h2 id="opus-编码简介"><a href="#opus-编码简介" class="headerLink" title="opus-编码简介"></a>Opus 编码简介</h2><p>音频信号处理中将音频（Audio）分为两大类：语音（Speech）和音乐（Music）。语音一般由人声带发出，人说话时语音的频率一般在 300 ~ 3400 Hz 之间，频率比较低。而音乐包含各种乐器演奏的声音，频率范围更广，涵盖了人耳能够听到的 20 ~ 20 kHz。由于两类音频频率范围各有特点，因此一般会采用不同的技术来处理。</p><p>Opus 编码格式应用了两种技术：一个是<strong>线性预测</strong>（Linear Prediction，LP），另一个是<strong>改进的离散余弦变换</strong>（Modified Discrete Cosine Transform，MDCT）。线性预测技术在低频信号的编码上更加高效，适合处理语音数据。对于包含高频信号的音乐，改进的离散余弦变换这种域变换技术处理效率更高。</p><p>Opus 编码格式采用的技术不是全新的，它使用的线性预测技术来自于 Skype 发明的 SILK 编解码器，而改进的离散余弦变换技术来自于 CELT （Constrained-Energy Lapped Transform）。CELT 也是由 <a href="https://xiph.org/" target="_blank" rel="noopener">Xiph.Org</a> 基金会早期发明一种音频编码格式，现在合并入 Opus 项目后，就不再有独立的 CELT 格式了。</p><p>为了对不同频率的音频应用不同的编码技术，Opus 音频频率带宽做了如下划分和命名：</p><table><thead><tr class="header"><th style="text-align: left;">缩写（全称）</th><th style="text-align: right;">音频带宽</th><th style="text-align: right;">应用采样率</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">NB (narrowband)</td><td style="text-align: right;">4 kHz</td><td style="text-align: right;">8 kHz</td></tr><tr class="even"><td style="text-align: left;">MB (medium-band)</td><td style="text-align: right;">6 kHz</td><td style="text-align: right;">12 kHz</td></tr><tr class="odd"><td style="text-align: left;">WB (wideband)</td><td style="text-align: right;">8 kHz</td><td style="text-align: right;">16 kHz</td></tr><tr class="even"><td style="text-align: left;">SWB (super-wideband)</td><td style="text-align: right;">12 kHz</td><td style="text-align: right;">24 kHz</td></tr><tr class="odd"><td style="text-align: left;">FB* (fullband)</td><td style="text-align: right;">20 kHz</td><td style="text-align: right;">48 kHz</td></tr></tbody></table><blockquote><p>根据奈奎斯特采样定理，应用 48 kHz 的采样率，实际上可以处理 24 kHz 以内的音频信号，但是即便如此，Opus 也不会处理超过 20 kHz 的音频，因为超过 20 kHz 的音频人耳已经很难听到了。</p></blockquote><p>Opus 编码器在处理音频的时候，会将音频划分成多个<strong>帧</strong>（Frame）之后，针对每帧来处理。Opus 支持的帧长有：2.5ms、5ms、10ms、20ms、40ms、60ms。</p><p>Opus 工作在 SILK 模式时，支持 NB、MB、WB 频率带宽的音频，并且帧长在 10ms ~ 60ms 之间。工作在 CELT 模式时，支持 NB、WB、SWB、FB 音频带宽，并且帧长在 2.5ms ~ 20ms 之间。Opus 还可以工作在混合模式（Hybrid），也就是 SILK 和 CELT 同时起作用，这种情况下只支持 SWB 、FB 音频带宽，并且帧长为 10ms 或 20ms。</p><h2 id="opus-包结构"><a href="#opus-包结构" class="headerLink" title="opus-包结构"></a>Opus 包结构</h2><p>Opus 编码器处理原始数据输出一串包（Packet），一个包里面可能包含多个编码后的音频帧数据，只是这些音频帧的参数必须是一致的，例如：编码模式、音频带宽、帧大小以及声道数。</p><p>下面详细描述 Opus 包的结构。</p><h3 id="toc-字节"><a href="#toc-字节" class="headerLink" title="toc-字节"></a>TOC 字节</h3><p>每个 Opus 包以一个 TOC （Table of Contents）字节开头，其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s| c |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这个字节由三部分组成：配置数（config），立体声标志（s），帧数（c）。</p><p>前 5 位的配置数定义了 32 种编码配置，不同的编码模式、音频带宽和帧长度组成了这 32 种配置，如下表所示：</p><table><thead><tr class="header"><th style="text-align: left;">配置数（config）</th><th style="text-align: left;">编码模式</th><th style="text-align: left;">音频带宽</th><th style="text-align: left;">帧长度</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0...3</td><td style="text-align: left;">SILK-only</td><td style="text-align: left;">NB</td><td style="text-align: left;">10, 20, 40, 60 ms</td></tr><tr class="even"><td style="text-align: left;">4...7</td><td style="text-align: left;">SILK-only</td><td style="text-align: left;">MB</td><td style="text-align: left;">10, 20, 40, 60 ms</td></tr><tr class="odd"><td style="text-align: left;">8...11</td><td style="text-align: left;">SILK-only</td><td style="text-align: left;">WB</td><td style="text-align: left;">10, 20, 40, 60 ms</td></tr><tr class="even"><td style="text-align: left;">12...13</td><td style="text-align: left;">Hybrid</td><td style="text-align: left;">SWB</td><td style="text-align: left;">10, 20 ms</td></tr><tr class="odd"><td style="text-align: left;">14...15</td><td style="text-align: left;">Hybrid</td><td style="text-align: left;">FB</td><td style="text-align: left;">10, 20 ms</td></tr><tr class="even"><td style="text-align: left;">16...19</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">NB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr><tr class="odd"><td style="text-align: left;">20...23</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">WB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr><tr class="even"><td style="text-align: left;">24...27</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">SWB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr><tr class="odd"><td style="text-align: left;">28...31</td><td style="text-align: left;">CELT-only</td><td style="text-align: left;">FB</td><td style="text-align: left;">2.5, 5, 10, 20 ms</td></tr></tbody></table><p>立体声标志位（s）取值 0 表示单声道，1 表示多声道立体声。</p><p>TOC 中最后两位（c）表示：</p><ul><li>0：一个包中只有一帧音频。</li><li>1：一个包中有两帧音频，并且大小相同。</li><li>2：一个包中有两帧音频，但是大小不同。</li><li>3：一个包中有任意帧音频。</li></ul><h3 id="不同帧结构的包"><a href="#不同帧结构的包" class="headerLink" title="不同帧结构的包"></a>不同帧结构的包</h3><p>根据一个包的 TOC 字节中帧数（c）的不同取值，我们把这个包命名为：<strong>c 号包</strong>。下面我们介绍这 4 种不同帧结构的包。</p><blockquote><p><strong>帧长度编码</strong><br />当一个包含有多个 VBR 的音频帧时，那么除了最后一个音频帧，前面几个帧都需要对帧的长度进行编码。存储帧长度的编码占用 1 ~ 2 个字节，其规则如下：<br />- 第一个字节取值为 0：表示没有任何帧数据（这通常是非连续传输（DTX）或者音频包丢失）<br />- 第一个字节取值为 1 ~ 251：表示第一帧的字节数<br />- 第一个字节取值为 252 ~ 255：第二个字节也参与编码帧长度，第一帧的总字节数为：<code>(第二字节*4)+第一字节</code></p><p>因此一个帧的最大长度为：255 * 4 + 255 = <strong>1275</strong> 字节。对于一个 20ms 的帧来说，这个长度代表 510 kbit/s 的码率。这个码率几乎是立体声音乐的有损压缩编码最高有效码率。超过这个码率，最好采用无损编码。这也是 MDCT 算法的最高有效码率，超过这个值，在增加码率进行编码，音频的质量也不会跟着提高。</p></blockquote><h4 id="号包-一个包只包含一帧音频"><a href="#号包-一个包只包含一帧音频" class="headerLink" title="号包-一个包只包含一帧音频"></a>0 号包: 一个包只包含一帧音频</h4><p>其包结构如下，TOC 字节之后，紧跟着一帧音频的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|0|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+                                               |</span><br><span class="line">|                    Compressed frame 1 (N-1 bytes)...          :</span><br><span class="line">:                                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>后面这帧音频有可能是 0 个字节，这也是合法的 0 号包，这样的话这个包就只有一个 TOC 字节。</p><h4 id="号包-一个包里面含有两个大小相同的帧"><a href="#号包-一个包里面含有两个大小相同的帧" class="headerLink" title="号包-一个包里面含有两个大小相同的帧"></a>1 号包: 一个包里面含有两个大小相同的帧</h4><p>TOC 字节后，紧跟着两个帧的数据，两个帧的大小各占这个包剩下字节数的一半。由此可以看出，1 号包的大小必定为奇数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|1|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+                                               :</span><br><span class="line">|             Compressed frame 1 ((N-1)&#x2F;2 bytes)...             |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|             Compressed frame 2 ((N-1)&#x2F;2 bytes)...             |</span><br><span class="line">:                                               +-+-+-+-+-+-+-+-+</span><br><span class="line">|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h4 id="号包-一个包里面含有两个大小不同的帧"><a href="#号包-一个包里面含有两个大小不同的帧" class="headerLink" title="号包-一个包里面含有两个大小不同的帧"></a>2 号包: 一个包里面含有两个大小不同的帧</h4><p>这种情况下，因为一个音频包里面包含了两个大小不同的音频帧，因此需要对第一个帧的字节数编码，否则无法区分开两个帧。TOC 字节后面的 1 ~ 2 个字节为第一个帧的字节数，其规则如前面所述的<strong>帧长度编码</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|0| N1 (1-2 bytes):                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|                     Compressed frame 2...                     :</span><br><span class="line">:                                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h4 id="号包-一个包里面含有任意个帧"><a href="#号包-一个包里面含有任意个帧" class="headerLink" title="号包-一个包里面含有任意个帧"></a>3 号包: 一个包里面含有任意个帧</h4><p>这种类型的包在 TOC 字节之后，有一个字节编码这个包里面的帧数量，这个字节的结构如下图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|v|p|     M     |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>帧数量字节包含三部分信息：</p><ul><li>v 等于 0 表示 CBR，等于 1 表示 VBR。</li><li>p 等于 1 表示包里面含有填充字节。</li><li>M 表示包里面含有的帧个数。</li></ul><p>规定一个包所包含的音频长度不能超过 120ms，如果按最小的帧长 2.5ms 计算，一个包的音频包所含有的音频帧不会超过 48 个。</p><p>当音频包里面含有填充字节时，帧数量字节后面的字节用于编码填充字节的长度。如果帧数量字节后面的那个字节值为 N (0~254)，则表示包后面的填充字节数加上当前这个表示填充字节长度的字节总共为 N 个字节。如果帧数量字节后面的那个字节值为 255，那么表示包后面的填充了254个字节，并且这个字节后面的一个字节编码了更多的填充字节数。以此类推，可以编码任意长度的填充字节数。</p><p>假如 P 表示填充字节的总数（包含编码填充字节长度的字节数），N 表示整个音频包的字节数。</p><p>那么对于 CBR 编码，R = N-2-P 就是有效音频数据的字节数。包里面每个音频帧的字节数量为 R/M，如下图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|0|p|     M     |  Padding length (Optional)    :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (R&#x2F;M bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (R&#x2F;M bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                              ...                              :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame M (R&#x2F;M bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 VBR 编码的情况，填充长度字节的后面跟上了 M - 1 个帧长度的编码，每个帧长度都会用一到两个字节做如前面所述的<strong>帧长度编码</strong>。其包结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|1|p|     M     | Padding length (Optional)     :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">: N1 (1-2 bytes): N2 (1-2 bytes):     ...       :     N[M-1]    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                              ...                              :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:                     Compressed frame M...                     :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从上面 0 ~ 3 号包的结构可以看到，虽然有帧长度编码信息区分出包内的每个帧，但是包没有编码自己的总长度信息，因此如果编码器输出的多个包直接拼接存储在一起，那么没有办法区分出每个包的边界，编码器也就没有办法解码这种裸的编码流。为了让解码器能够处理 Opus 裸流，需要将其封装在一种容器格式中（例如 Ogg 格式），让容器格式提供分包的信息。</p><h3 id="合法音频包的验证条件"><a href="#合法音频包的验证条件" class="headerLink" title="合法音频包的验证条件"></a>合法音频包的验证条件</h3><p>根据前面描述，我们可以通过以下几个约束条件来判断一个 Opus 包是否合法：</p><ol type="1"><li>音频包至少包含一个字节，即 TOC 字节。</li><li>一个音频帧的长度不能超过 1275 字节。</li><li>1 号音频包的字节数必须是奇数，使得 <code>(N-1)/2</code> 计算出来是整数。</li><li>2 号音频包的 TOC 字节后面必须有足够的字节数用于编码帧长度，而且帧长度不能大于音频包剩下的字节数。</li><li>3 号音频包至少包含一个音频帧，但是总的音频长度不得超过 120ms。</li><li>CBR 的 3 号包至少包含 2 个字节。添加在音频包后面的填充字节数和表示填充长度的字节数之和 P 不能大于 N-2，而且 (N-2-P) 是帧个数 M 的倍数。</li><li>VBR 的 3 号包必须足够大到容纳所有的包头字节，以及对应的前 M-1 个帧的长度，和填充字节数。</li></ol><h2 id="带分界的音频包"><a href="#带分界的音频包" class="headerLink" title="带分界的音频包"></a>带分界的音频包</h2><p>如前所述，Opus 包与包之间没有界限，需要额外的机制告诉解码器每个包的大小。不过除此之外，Opus 标准还定义了一种<strong>带分界</strong>（Self-Delimiting）的音频包，编码器拿到这种包可以直接推断出包的大小。</p><p>从前面描述的 0 ~ 3 号包结构来看，对于包含 CBR 的包，由于每个帧长度一样，只需要再添加一个帧的长度编码就可以确定这个包的总大小；对于 VBR 的包，由于包里面已经含有了除最后一个帧的长度编码，只需要再添加最后一帧的长度编码就可以算出包的总大小。不管哪种情况，这个长度编码都采用前面提到的 1 ~ 2 字节的<strong>帧长度编码</strong>。下面分别描述 0 ~ 3 号包是如何添加这个长度编码的。</p><p>对于 0 号包，在 TOC 字节后面，添加帧长度编码，表示后面这个帧的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|0| N1 (1-2 bytes):                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">:                                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 1 号包，在 TOC 字节后面，添加帧长度编码，表示后面每个帧的大小。如果这个编码的值为 N1，那么后面两个帧的总大小为 2 * N1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|0|1| N1 (1-2 bytes):                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">|               Compressed frame 2 (N1 bytes)...                |</span><br><span class="line">:                                               +-+-+-+-+-+-+-+-+</span><br><span class="line">|                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 2 号包，在第一帧数据前面，添加第二帧的长度编码，表示第二帧的大小。如果这个编码的值为 N2，那么两个帧的总大小为 N1 + N2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|0| N1 (1-2 bytes): N2 (1-2 bytes):               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               :</span><br><span class="line">|               Compressed frame 1 (N1 bytes)...                |</span><br><span class="line">:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">:                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 CBR 的 3 号包，在第一帧前面，添加帧长度编码，表示后面每个帧的大小。如果这个编码的值为 N1，那么后面 M 个帧的总大小为 M * N1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|0|p|     M     | Pad len (Opt) : N1 (1-2 bytes):</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                              ...                              :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame M (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于 VBR 的 3 号包，在第一帧前面，添加帧长度编码，表示最后一个帧的大小。如果这个编码的值为 N[M]，那么后面 M 个帧的总大小为 N1 + N2 + ... + N[M]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| config  |s|1|1|1|p|     M     | Padding length (Optional)     :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">: N1 (1-2 bytes):     ...       :     N[M-1]    |     N[M]      :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                              ...                              :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">:              Compressed frame M (N[M] bytes)...               :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                  Opus Padding (Optional)...                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>从上面的描述我们可以看到，实际上这个额外的帧长度编码都是在原来的包结构基础上，插入到了第一帧数据的前面。</p><p>在一些场景下，带分界包有实际的用途。根据标准，Opus 只能编码单声道或者双声道立体声音频。因此一个 Opus 码流要不就是单声道的，要不就是双声道的。如果要传输或者存储多声道（大于2）的音频，就需要复合多个 Opus 流。例如 5.1 环绕立体声有 6 个声道，传输或者存储这样一个音频，可能需要组合多个单声道或双声道的 Opus 流。</p><p>假如 5.1 环绕立体声由 2 个双声道，2 个单声道的 Opus 流组成。那么需要将这 4 个 Opus 流复合成一个流，每次从 4 个 Opus 流中各取一个包，组成一个复合音频包。每个复合音频包就包含四个包，分别来自同一时刻不同的 Opus 流。为了让解码器能够顺利从复合音频包中识别出四个包，就需要让前三个包采用带分界格式的编码。一般来说复合包的总大小会通过容器格式或者传输协议信息告诉解码器，因此复合包里面最后一个子 Opus 包不需要采用带分界包格式，可以直接推断出来。</p><p><strong>参考文献：</strong></p><p>[1] Voice frequency: https://en.wikipedia.org/wiki/Voice_frequency<br />[2] CELT: https://en.wikipedia.org/wiki/CELT<br />[3] Definition of the Opus Audio Codec: https://tools.ietf.org/html/rfc6716<br />[4] 5.1 surround sound: https://en.wikipedia.org/wiki/5.1_surround_sound</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;音频编码是将原始的音频采样数据，通过某种算法将其压缩编码成规定格式的二进制码流，从而方便存储和传输。Opus 就是由 &lt;a href=&quot;https://xiph.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xiph.Org&lt;/a&gt; 基金会发明的一种音频编码格式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Audio Tech" scheme="http://chenliang.org/categories/Audio-Tech/"/>
    
    
      <category term="Opus" scheme="http://chenliang.org/tags/Opus/"/>
    
  </entry>
  
  <entry>
    <title>Ogg 容器格式</title>
    <link href="http://chenliang.org/2020/03/14/ogg-container-format/"/>
    <id>http://chenliang.org/2020/03/14/ogg-container-format/</id>
    <published>2020-03-14T22:34:12.000Z</published>
    <updated>2020-07-12T03:47:32.298Z</updated>
    
    <content type="html"><![CDATA[<p>Ogg是<a href="https://xiph.org/" target="_blank" rel="noopener">Xiph.Org</a>基金会推出的一种开源免费的多媒体容器格式。Ogg容器格式可以用于封装音频、视频、字幕、以及多媒体元信息。它既适用于流媒体传输，又能作为文件格式存储多媒体。</p><a id="more"></a><blockquote><p>容器格式和编码格式有区别。编码指的是将原始多媒体数据按照规定的算法将原始数据进行压缩编码，使其占用的空间更小，方便传输和存储。这个压缩编码的算法就叫做编码格式，例如视频的编码格式有：H.264、H.265（又叫做HEVC）、Theora等等，音频的编码格式有：Vorbis、ACC、FLAC、Opus等等。实现这些压缩编码算法的软件叫做编码器。而容器格式是用来封装编码之后的数据，容器格式提供了分包机制和元信息可以帮助解码器解码，而且容器可以将多种不同的编码数据复合在一起，例如视频、音频、字幕可以封装到一个容器格式里面。常用的容器格式有：MKV、MP4、AVI等等，Ogg也是容器格式一种。</p></blockquote><h2 id="ogg-二进制流"><a href="#ogg-二进制流" class="headerLink" title="ogg-二进制流"></a>1. Ogg 二进制流</h2><p>多媒体编码器输出的是一串二进制包（Packet），包通常是解码器解码的最小单位。这些包之间通常没有分割标志，如果直接把这些包拼接在一起形成一个二进制流，那么没有任何解码器可以读出其中的包并进行解码，因为解码器将找不到每个包从哪里开始，从哪里结束。</p><figure><img src="/images/ogg_container_format/1.png" alt="" /><figcaption>裸的二进制包缺乏分割标志，拼在一起将无法被处理</figcaption></figure><p>Ogg容器格式将多媒体编码器产生的二进制包进行封装，并且提供分割信息，这样解码器就可以通过读取Ogg格式的封装信息，将二进制包一个一个拆出来进行解码。</p><p>我们将编码器生成的二进制流称为<strong>逻辑流</strong>（Logical Bitstream），把Ogg封装之后二进制流称为<strong>物理流</strong>（Physical Bitstream）。之所以这么称呼是因为编码生成的裸二进制流实际上无法被任何工具处理，只能存在于逻辑概念，而 Ogg 封装过后的流却是可以被实际操作处理的。</p><figure><img src="/images/ogg_container_format/2.png" alt="" /><figcaption>将裸的二进制流封装之后成为物理流</figcaption></figure><p>Ogg物理流的基本组成单位是 <strong>Ogg 页</strong>（Ogg Page）。编码器输出的二进制包就是按照Ogg格式的规则放到Ogg页中的。Ogg的规范十分灵活，一个Ogg页可以存放一个包、多个包、甚至是一包的一部分。正因为Ogg格式对编码器输出的包大小没有要求，使得Ogg格式可以用于多种视频、音频编码格式的封装。</p><p>一个Ogg物理流中可以包含多个逻辑流，例如一个Ogg文件中包含了视频、音频以及字幕三个逻辑流。如果一个Ogg流只有一个逻辑流，那么它称为一个<strong>基础流</strong> （Elementary Bitstream），如果包含多个逻辑流，那么它称为<strong>复合流</strong>（Multiplexed Bitstream）。</p><p>多个基础流通过Ogg页交错的方式组合成一个复合流，也就是将不同基础流中同样时间点的Ogg页放到一起。</p><figure><img src="/images/ogg_container_format/3.png" alt="" /><figcaption>多个流复合成一个流</figcaption></figure><h2 id="ogg-页的格式"><a href="#ogg-页的格式" class="headerLink" title="ogg-页的格式"></a>2. Ogg 页的格式</h2><p>Ogg页是Ogg物理流的基本单位。一个Ogg页由头和负载两部分组成，并且总是由<code>OggS</code>四个字节开头，这四个字节称为捕获标志（Capture Pattern）。当客户端解码器从中途开始接收服务端推送的流媒体比特流时，搜索到比特流中的第一个<code>OggS</code>标志，就可以从这里开始进行比特流的解码。</p><p>Ogg页头部格式如下图所示：</p><figure><img src="/images/ogg_container_format/4.png" width="400" alt="" /><figcaption>Ogg头部结构</figcaption></figure><h3 id="捕获标志capture"><a href="#捕获标志capture" class="headerLink" title="捕获标志capture"></a>2.1 捕获标志（Capture）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 0   0x4f  &#39;O&#39;</span><br><span class="line"> 1   0x67  &#39;g&#39;</span><br><span class="line"> 2   0x67  &#39;g&#39;</span><br><span class="line"> 3   0x53  &#39;S&#39;</span><br></pre></td></tr></table></figure><p>固定值<code>OggS</code>。</p><h3 id="版本号version"><a href="#版本号version" class="headerLink" title="版本号version"></a>2.2 版本号（Version）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 4   0x00</span><br></pre></td></tr></table></figure><p>Ogg格式的版本号，目前固定为0。</p><h3 id="头类型标志header-type"><a href="#头类型标志header-type" class="headerLink" title="头类型标志header-type"></a>2.3 头类型标志（Header Type）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 5   bitflags: 0x01: 置0 &#x3D; 从新的包开始</span><br><span class="line">                     置1 &#x3D; 这个页里面的包接着上一个页里面的包</span><br><span class="line">               0x02: 置0 &#x3D; 不是逻辑流的第一个Ogg页</span><br><span class="line">                     置1 &#x3D; 逻辑流的第一个Ogg页（bos）</span><br><span class="line">               0x04: 置0 &#x3D; 不是逻辑流的最后一个Ogg页</span><br><span class="line">                     置1 &#x3D; 逻辑流的最后一个Ogg页（eos）</span><br></pre></td></tr></table></figure><p>占一个字节，根据最低的三个比特位是否设置为1表示不同的信息。</p><p>这里特别说明一下最低位<code>0x01</code>的意义，当一个包太大，导致一个Ogg页放不下，或者Ogg页已经放了很多个包，剩下的位置不够再放一个包，那么一个包就可能横跨两个连续的Ogg页。这个包开头的部分在第一页，后半部分在第二页。这种情况下，第二页的头类型标志的最低位就会置为1。</p><h3 id="位置数granule-position"><a href="#位置数granule-position" class="headerLink" title="位置数granule-position"></a>2.4 位置数（Granule Position）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line"> 6   0xXX LSB</span><br><span class="line"> 7   0xXX</span><br><span class="line"> 8   0xXX</span><br><span class="line"> 9   0xXX</span><br><span class="line">10   0xXX</span><br><span class="line">11   0xXX</span><br><span class="line">12   0xXX</span><br><span class="line">13   0xXX MSB</span><br></pre></td></tr></table></figure><p>从上面的字节序可以看出位置数采用小端字节序，这也是Ogg的默认字节序。</p><p>每个Ogg页上的位置数表示从这个逻辑流开始，到这个Ogg页上最后一个完结的包所包含的样本数。如果一个包只有开头或中间的一部分在这个Ogg页里面，那么这部分的包含的样本数不计算在位置数里面。</p><p>如果这个值为<code>-1</code>（以补码表示），那么说明这个页里面没有任何完结的包。</p><p>下面用一个例子来说明位置数。一个逻辑流由6个包组成，这个包按照下图的方式封装在4个Ogg页里面形成一个Ogg物理流。</p><ul><li>Ogg页1里面包2是这个页里面最后一个完结的包，从开头的包1开始算起，到这个包2一共有40个样本，因此Ogg页1的位置数为40。</li><li>Ogg页2里面没有任何一个包是在该页结束的，因此位置数为-1。</li><li>Ogg页3里面最后一个完结的包是包4，从开始到包4结尾一共有120个样本数，因此Ogg页3的位置数为120。</li><li>Ogg页4里面最后一个完结的包是包6，从开始到包6结尾一共有160个样本数，因此Ogg页4的位置数为160。</li></ul><figure><img src="/images/ogg_container_format/5.png" alt="" /><figcaption>位置数与包大小和排列的关系</figcaption></figure><p>对于不同类型的多媒体和编解码器，位置数的含义不一样，例如对于视频来说，它表示帧数，对于音频来说，它表示采样数。</p><h3 id="逻辑流编号bitstream-serial-number"><a href="#逻辑流编号bitstream-serial-number" class="headerLink" title="逻辑流编号bitstream-serial-number"></a>2.5 逻辑流编号（Bitstream Serial Number）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">14   0xXX LSB</span><br><span class="line">15   0xXX</span><br><span class="line">16   0xXX</span><br><span class="line">17   0xXX MSB</span><br></pre></td></tr></table></figure><p>当多个逻辑流复合在一个Ogg物理流里面时，每个逻辑流都会有一个独特的编号，其对应的Ogg页都打上对应编号，用于区分这个Ogg页属于哪一个逻辑流。</p><h3 id="页序列号page-sequence-no"><a href="#页序列号page-sequence-no" class="headerLink" title="页序列号page-sequence-no"></a>2.6 页序列号（Page Sequence No）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">18   0xXX LSB</span><br><span class="line">19   0xXX</span><br><span class="line">20   0xXX</span><br><span class="line">21   0xXX MSB</span><br></pre></td></tr></table></figure><p>Ogg流里面每个Ogg页都有一个按顺序增长的序号，这样如果在传输的时候有一页丢失了，解码器可以通过检查序号很快发现丢失的页。</p><p>如果一个Ogg物理流里面有多个逻辑流，那么每个逻辑流的Ogg页序列号是独立增长的。</p><h3 id="校验和checksum"><a href="#校验和checksum" class="headerLink" title="校验和checksum"></a>2.7 校验和（Checksum）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">22   0xXX LSB</span><br><span class="line">23   0xXX</span><br><span class="line">24   0xXX</span><br><span class="line">25   0xXX MSB</span><br></pre></td></tr></table></figure><p>当前整个Ogg页的CRC校验和，计算包括头部数据，只是在计算前将校验和字段的四个字节置为0，计算后将得到的值再设置进去。</p><p>计算时，初始值和最后的XOR值为0，generator polynomial 为 0x04c11db7。</p><h3 id="分段个数page-segments分段表segment-table"><a href="#分段个数page-segments分段表segment-table" class="headerLink" title="分段个数page-segments分段表segment-table"></a>2.8 分段个数（Page Segments）、分段表（Segment Table）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">26   0x00-0xff (0-255)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte value</span><br><span class="line">27   0x00-0xff (0-255)</span><br><span class="line">[...]</span><br><span class="line">n    0x00-0xff (0-255, n&#x3D;page_segments+26)</span><br></pre></td></tr></table></figure><p>Ogg格式规定将一个包看成由多个大小为255字节的分段和最后一个可能小于255字节分段组成。例如一个包的大小为702字节，那么可以看是由三个分段组成大小分别为：255、255、192。如果将这个包封装到Ogg页中，那么Ogg头里面的<strong>分段个数</strong>值为3，<strong>分段表</strong>将有三个字节，值分别为：255、255、192。</p><p><strong>分段个数</strong>占一个字节，表示这个Ogg页里面有多少个包的分段。<strong>分段表</strong>的大小由<strong>分段个数</strong>决定，其中每个字节的值代表了对应分段的大小。</p><p>这个分段机制为解码器提供了区分包边界的方法，如果分段表中一个值小于255，那么代表这个包已经结束了，下一个分段就代表一个新的包开始。</p><p>用一个例子来说明这个机制，下图有三个包存储在了两个Ogg页中。</p><figure><img src="/images/ogg_container_format/6.png" width="350" alt="" /><figcaption>Ogg分段示意图</figcaption></figure><ul><li>包1大小为702字节，可以分成三个段：255、255、192。</li><li>包2大小为574字节，可以分成三个段：255、255、64。</li><li>包3大小为638字节，可以分成三个段：255、255、128。</li></ul><p>Ogg页1包含整个包1和包2的前两个分段，因此Ogg页1头里面的分段个数字段的值为5，分段表有5个字节，5个字节的值分别为：255、255、192、255、255。当解码器读到分段表中192这个数时，就知道这个包已经结束，可以开始解码包1的数据了。</p><p>Ogg页2包含整个包3和包2的最后一个分段，因此Ogg页2头里面的分段个数字段的值为4，分段表有4个字节，4个字节的值分别为：64、255、255、128。并且由于Ogg页2开头的数据是接着上一个Ogg页的，因此它头类型标志最低位将会设置为1。</p><p>有种特殊情况，如果一个包大小恰好为255的倍数，例如包大小为510，如果按照上面的分段方法，那么应该分成两段：255、255。但是这样依赖，解码器在分段表里面读到第二个255，并不能判断这个包是不是结束了。为了解决这个问题，Ogg规定在分段表里面插入一个0值，也就是说这个包可以看成分成三个段：255、255、0。解码器读到这个0的时候就知道这个包结束了。这个0值只存在于分段表中，不会真的在负载的包中插入数据。</p><p>从上面的分析可以看出Ogg格式对包的分段只是逻辑上的，只是用于计算分段个数和分段表中的值，并不会在负载中的包里面插入任何分隔符。</p><p>由于分段个数只占一个字节，它的最大值为255，分段表中每个分段值也只占一个字节，对应的分段大小最大为255字节。因此一个Ogg页的最大有效负载为 255 * 255 = 65025 字节，这种情况下，Ogg页的头大小为 ：27（固定大小） + 255（分段表大小） = 282 字节。整个Ogg页最大的长度为 65025 + 282 = 65307。</p><p>这个逻辑上的分段机制可以看出，虽然Ogg页的大小有限制，但是对于多媒体编码器输出的包大小没有限制，大于65025字节的包可以分开在多个连续的Ogg页里面存储，分段机制保证了解码器可以识别到包的开始和结尾。</p><h2 id="ogg-媒体类型定义"><a href="#ogg-媒体类型定义" class="headerLink" title="ogg-媒体类型定义"></a>3. Ogg 媒体类型定义</h2><p>针对Ogg格式，Xiph.Org在IANA注册了三种MIME类型。分别是：</p><ul><li>application/ogg</li><li>video/ogg</li><li>audio/ogg</li></ul><p>在标准制定的早期，Ogg专门用来封装Vorbis编码格式的语音，并且在<a href="https://tools.ietf.org/html/rfc3534" target="_blank" rel="noopener">RFC3534</a>中定义了<code>application/ogg</code>类型来指代封装在Ogg格式中的Vorbis语音。不过随着技术的发展，Ogg被单独提出来作为一种可以封装任意媒体类型的容器格式。于是<a href="https://tools.ietf.org/html/rfc3534" target="_blank" rel="noopener">RFC3534</a>草案被废弃，在新的草案<a href="https://tools.ietf.org/html/rfc5334" target="_blank" rel="noopener">RFC5334</a>中重新定义了<code>application/ogg</code>的意义，并且定义了<code>video/ogg</code>和<code>audio/ogg</code>两种新的类型。</p><p><strong>video/ogg</strong></p><p>当一个Ogg流的主要信息是视频（可能包括音频和字幕），那么传输的时候应当使用<code>video/ogg</code>类型。存储成文件时应当使用<code>.ogv</code>扩展名。</p><p><strong>audio/ogg</strong></p><p>当一个Ogg流的主要信息是音频（可能包括字幕），那么传输的时候应当使用<code>audio/ogg</code>类型。存储成文件时应当使用<code>.oga</code>扩展名。</p><p>因为历史原因，Ogg格式的音频数据存储成文件时，也可以使用<code>.ogg</code>和<code>.spx</code>扩展名。<code>.ogg</code>表示音频编码格式是Vorbis；<code>.spx</code>表示音频编码格式是Speex。</p><p><strong>application/ogg</strong></p><p>当一个Ogg流非常复杂，不是单纯的视频或者音频，例如传输多路视频信号，这种情况下就建议使用<code>application/ogg</code>类型。存储文件使用<code>.ogx</code>扩展名。</p><p>对于这些MIME类型，还可以指定<code>codec</code>参数来表示Ogg流中的数据编码格式。例如传输Opus格式语音就可以使用：<code>audio/ogg; codecs=opus</code>。目前支持的codec可以参考https://wiki.xiph.org/index.php/MIMETypesCodecs。</p><hr /><p><strong>参考文献：</strong><br />[1] Ogg bitstream overview: https://www.xiph.org/ogg/doc/oggstream.html<br />[2] Ogg logical bitstream framing: https://www.xiph.org/ogg/doc/framing.html<br />[3] Ogg: https://en.wikipedia.org/wiki/Ogg<br />[4] Ogg Media Types: https://tools.ietf.org/html/rfc5334<br />[5] Specification of MIME types and respective codecs parameter: https://wiki.xiph.org/index.php/MIMETypesCodecs<br />[6] The application/ogg Media Type: https://tools.ietf.org/html/rfc3534<br />[7] The Ogg Encapsulation Format Version 0: https://tools.ietf.org/html/rfc3533</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ogg是&lt;a href=&quot;https://xiph.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xiph.Org&lt;/a&gt;基金会推出的一种开源免费的多媒体容器格式。Ogg容器格式可以用于封装音频、视频、字幕、以及多媒体元信息。它既适用于流媒体传输，又能作为文件格式存储多媒体。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Audio Tech" scheme="http://chenliang.org/categories/Audio-Tech/"/>
    
    
      <category term="Ogg" scheme="http://chenliang.org/tags/Ogg/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础知识</title>
    <link href="http://chenliang.org/2018/10/12/docker-basics/"/>
    <id>http://chenliang.org/2018/10/12/docker-basics/</id>
    <published>2018-10-12T11:22:09.000Z</published>
    <updated>2020-07-12T03:47:32.298Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是目前最流行的容器技术，它将开发和运维带入了一个新的时代。本文主要介绍 Docker 的一些基本概念和常用命令。</p><a id="more"></a><h3 id="image"><a href="#image" class="headerLink" title="image"></a>Image</h3><p>Image (镜像) 是一个不可变的文件。它好比是一个可执行程序文件，操作系统执行程序时，将程序文件加载到内存执行，成为系统中的一个进程。而 Docker 通过<code>docker run</code>命令加载镜像文件执行，成为 Docker Container (容器)。</p><p>开发者编写 Dockerfile 文件，然后使用<code>docker build</code>命令来创建镜像。开发者可以将自己的镜像通过<code>docker push</code>上传到 Docker Registry 上，分享给其他人使用。其他人通过<code>docker pull</code>拉取镜像。官方的 Docker Registry 是 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，也可以自己搭建私有的 Registry。</p><p>Docker Registry 就和 GitHub 一样，是大家共享 Docker Image 的地方。其管理方式也是建立 repository (仓库)，每个仓库里面放一个镜像，随着开发的不断进行，仓库里面的镜像会有多个版本，在 Docker Registry 里面“版本”也称作 Tag (标签)。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 helloworld 的镜像，"."代表在当前目录，里面要有 Dockerfile 文件</span></span><br><span class="line">docker build -t helloworld .  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前系统中的所有镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录 Docker Hub</span></span><br><span class="line">docker login </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了将本地镜像上传到 Docker Registry，要先按照规则给本地镜像加 tag</span></span><br><span class="line"><span class="comment">#   &lt;image&gt; 是本地镜像的名字</span></span><br><span class="line"><span class="comment">#   &lt;username&gt; 是在 Docker Registry 上注册的 Docker ID；</span></span><br><span class="line"><span class="comment">#   &lt;repository&gt; 是 Docker Registry 上的仓库的名称</span></span><br><span class="line"><span class="comment">#   &lt;tag&gt; 用来区分这个镜像的不同版本</span></span><br><span class="line">docker tag &lt;image&gt; &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传镜像到 Docker Register</span></span><br><span class="line">docker push &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 Docker Register 下载镜像到本地</span></span><br><span class="line">docker pull &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p><h3 id="container"><a href="#container" class="headerLink" title="container"></a>Container</h3><p>Container (容器) 就是执行中的镜像。之所以叫容器，是因为 Container 使用隔离技术，像“容器”一样，把容器中的文件和执行的进程与宿主系统隔离开来。虽然是与宿主机隔离的，进程还是执行在宿主机系统本地的。这与传统的一样虚拟机（VM）技术不一样，它的进程是执行在虚拟的操作系统中的，与宿主操作系统没关系。</p><figure><img src="/images/docker_basics_vm_and_docker_compare.png" alt="" /><figcaption>VM vs. Docker</figcaption></figure><p>Container 这种“软”隔离得益于 Linux 内核的 namespace 技术，因此 Docker 只适用于 Linux 系统。使用 namespace 技术，意味着容器中的进程还是在宿主机的内核中执行，但是因为命名空间(namespace)和其它进程不同，因此它只能看到自己所属容器中的资源。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载镜像 helloworld 到容器中运行，将容器中的 80 端口，映射到宿主系统的 4000 端口</span></span><br><span class="line">docker run -p 4000:80 helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同上，-d 选项使容器在后台执行</span></span><br><span class="line">docker run -d -p 4000:80 helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有运行中的 Container </span></span><br><span class="line">docker container ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 Container，包括没有处于运行状态的 </span></span><br><span class="line">docker container ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常停止 Container </span></span><br><span class="line">docker container stop &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制停止 Container </span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Container </span></span><br><span class="line">docker container rm &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有不是运行状态的 Container </span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure></p><h3 id="swarm"><a href="#swarm" class="headerLink" title="swarm"></a>Swarm</h3><p>Swarm 是多个运行 Docker 的主机组成的集群。集群中的主机又叫做 node (节点)，根据角色分为两类：Mananger 和 Worker。Mananger 通过 <code>docker swarm init</code>命令创建，负责管理整个集群的节点，在集群中执行 Docker 指令都是在 Manager 上执行的。Worker 通过 <code>docker swarm join</code>命令加入到集群中，Worker 负责执行任务，运行 Container。通过<code>docker stack</code>命令，可以将应用按照指定的方式部署在集群上。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Docker Swarm 集群，并且让本机成为这个 Swarm 集群的 Manager</span></span><br><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让主机作为 Worker 加入到 Swarm</span></span><br><span class="line"><span class="comment">#   &lt;token&gt; 是创建 Swarm 的时候生成的认证 token，</span></span><br><span class="line"><span class="comment">#   &lt;ip&gt;:&lt;port&gt; 是 Manager 的地址</span></span><br><span class="line">docker swarm join --token &lt;token&gt; &lt;ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 join token，需要在 Manager 主机上执行</span></span><br><span class="line">docker swarm join-token -q worker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个 Swarm 可以有多个 Manager，让主机作为 Manager 加入到 Swarm 中</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群中所有的节点</span></span><br><span class="line">docker node ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个节点的详情</span></span><br><span class="line">docker node inspect &lt;node ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Worker 主机上执行下面命令，离开集群</span></span><br><span class="line">docker swarm leave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Manager 主机上执行下面命令，离开集群，如果只有一个 Manager，那么集群会被关闭</span></span><br><span class="line">docker swarm leave -f</span><br></pre></td></tr></table></figure></p><h3 id="service"><a href="#service" class="headerLink" title="service"></a>Service</h3><p>Service 是运行同一个镜像的一组 Container，这些 Container 提供相同的服务。这是为了在产品环境中，让一个服务有多个运行实例做负载均衡，达到服务高可用的目的。Docker Service 是 Docker Swarm 中的概念，只能在 Swarm 中使用。</p><p>一个 Service 一般定义了需要使用什么端口、启动几个 Container、负载均衡的规则等等。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的 Service</span></span><br><span class="line">docker service ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出某个 service 下面的所有 Container</span></span><br><span class="line">docker service ps &lt;service name&gt;</span><br></pre></td></tr></table></figure></p><h3 id="stack"><a href="#stack" class="headerLink" title="stack"></a>Stack</h3><p>Stack 是在集群中由多个 Service 组成的完整应用。一个应用通常分为多个服务，例如一个前后端分离的网站，可能分为前端页面、后端API、数据库三个服务。在集群中部署的时候，我们需要定义这三个 Service，将三个 Service 的规则写到<code>docker-cloud.yml</code>，然后使用<code>docker stack</code>命令部署到集群中去。</p><p>Stack 的前身是 <strong>docker-compose</strong>，docker-compose 是以前用来启动多个 Container 的，它使用<code>docker-compose.yml</code>文件指定多个 Container 的执行规则。Docker Stack 现在替代了 Docker Compose 的功能，而且更强大，同时 Stack 也兼容<code>docker-compose.yml</code>文件。</p><p>常用命令：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署应用到 Swarm，docker-cloud.yml 文件描述了 Stack 所有的 Service。</span></span><br><span class="line">docker stack deploy -c docker-cloud.yml &lt;app name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的 stack</span></span><br><span class="line">docker stack ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个 Stack</span></span><br><span class="line">docker stack rm &lt;app name&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是目前最流行的容器技术，它将开发和运维带入了一个新的时代。本文主要介绍 Docker 的一些基本概念和常用命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://chenliang.org/categories/DevOps/"/>
    
    
      <category term="AWS" scheme="http://chenliang.org/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS VPC简介以及EC2的IPv6配置</title>
    <link href="http://chenliang.org/2017/09/14/aws-vpc/"/>
    <id>http://chenliang.org/2017/09/14/aws-vpc/</id>
    <published>2017-09-14T22:11:54.000Z</published>
    <updated>2020-07-12T03:47:32.298Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon VPC (Virtual Private Cloud) 是AWS的网络基础设施。使用VPC服务可以在AWS中创建一个独立隔离的网络，在这个隔离的网络空间中可以创建任何AWS资源，例如EC2、Redis、RDS数据库等等，VPC网络使这些AWS资源互相连接，传递数据，并且提供外网访问的网关。</p><p>实际上很多人可能不知道，如果你已经在使用AWS的EC2，你就已经在不知不觉中使用了VPC。当我们最开始使用AWS服务时，AWS为我们创建了一个默认的VPC网络，我们创建的EC2实例（如果不手动选择）都默认加入到了这个VPC网络中。EC2、RDS等资源必须创建在一个VPC网路中，才能互相联通，访问网络。</p><a id="more"></a><figure><img src="/images/default_vpc.png" alt="" /><figcaption>Default VPC</figcaption></figure><p>除了默认的VPC，我们也可以自己创建VPC网络。VPC同时支持IPv4和IPv6组网，一个VPC网络由多个部分组成。</p><h3 id="vpc和子网subnet"><a href="#vpc和子网subnet" class="headerLink" title="vpc和子网subnet"></a>VPC和子网(Subnet)</h3><p>当新建一个VPC，需要为虚拟网络定义IP地址范围作为CIDR地址，例如CIDR为<code>10.1.0.0/16</code>。IPv4的CIDR可以手动指定，但是IPv6的CIDR只能由AWS自动分配。</p><blockquote><p>CIDR（无类别域间路由，Classless Inter-Domain Routing）将IP地址按照前缀分成一组，使用一种无类别的域际路由选择算法，大大减少了路由表维护的条目数。</p></blockquote><p>VPC的IP地址段可以进一步划分IP段，从而创建子网(Subnet)。一个VPC横跨多个可用区(Availability Zone)，但是一个子网只能位于一个可用区里面。</p><p>创建EC2、RDS等AWS资源的时候，除了要选择VPC，还要选择创建到VPC的哪个子网里面。EC2会被自动分配一个所属子网IP段内的私有IP地址，如果想要分配公网IP地址，需要手动指定弹性IP，或者可以配置子网自动为EC2分配公网IP地址。如果想要让EC2被外网访问到，除了需要配置公网IP地址，还需要配置子网的路由表，使其可以通过VPC网关(Internet Gateway)访问外网。</p><p>Subnet是一个VPC里面一个IP段. 创建任何AWS资源的时候可以选择一个Subnet。</p><p>AWS 以前没有VPC，而是叫做EC2-Classic的网络。2013年之后就支持EC2-VPC了。 对于只支持VPC的新账户，会有一个Default VPC，并且在每个Availability Zone里面都有一个默认的Default Subnet，新账号就默认使用个VPC，而不用自己选择。当然也可以自己创建VPC。</p><p>Default VPC 里面默认配置了网关(Internet Gateway)，而且配置好了到网关的路由，每个Default Subnet里面的EC2都默认分配私有IP和公网IP。因此Default Subnet里面的EC2都是可以外网访问的。</p><h3 id="internet-gateway和route-table"><a href="#internet-gateway和route-table" class="headerLink" title="internet-gateway和route-table"></a>Internet Gateway和Route Table</h3><p>VPC是一个独立的虚拟的网络，与AWS其它的VPC、与外网都是隔离开得。如果想要让外网访问VPC里面的EC2，必须通过网关（Internet Gateway）。网关是VPC连接外网的组件，可以为VPC分配多个网关，每个网关都有唯一的ID，例如<code>igw-8727e8e2</code>。配置路由表的时候，网关ID作为路由表的目标地址（target）。</p><blockquote><p>如果只想让instance主动访问外网，不想让外网主动访问instance。IPv4可以使用<strong>NAT</strong>，IPv6可以使用<strong>Egress-Only Internet Gateways</strong>。</p></blockquote><p>VPC里面的Subnet都关联了一张路由表(Route Table)，路由表定义了VPC网络里面的网络流量的传输路径。</p><p>每个VPC创建之后都自动配置了一个路由表，这种关联在VPC上的路由表叫做主路由表(Main Route Table)。主路由表不能删除，但是可以替换为别的路由表。 每个Subnet创建之后默认使用主路由表，但是可以为Subnet创建一个自定义路由表(Custom Route Table)来设置特定路由规则。自定义路由表可以删除，删除之后就使用VPC的主路由表。</p><p>e.g. 一个使用主路由表的例子<br /><img src="/images/aws_vpc_subnets.png" alt="Default VPC" /></p><p>在上面这个例子中，VPC的网段为<code>10.1.0.0/16</code>，里面有两个子网：<code>10.1.1.0/24</code>和<code>10.1.2.0/24</code>。这两个子网没有自定义路由表，因此都使用VPC的主路由表。</p><p>主路由表中有两条路由规则：<br />- destination为<code>10.1.0.0/16</code>表示VPC内部的流量，因为VPC网段下的所有IP地址都是<code>10.1</code>开头。这些流量的target是<code>local</code>，表示内部之间通信。<br />- destination为<code>0.0.0.0/0</code>表示访问外网IP的流量，这些流量通过target指定ID的Internet Gateway访问外网。</p><h3 id="security-group"><a href="#security-group" class="headerLink" title="security-group"></a>Security Group</h3><p>安全组（Security Group）定义了防火墙规则，包括出站规则和入站规则，可以细化到哪个IP段可以访问哪个端口。</p><h3 id="为vpc中的ec2配置ipv6"><a href="#为vpc中的ec2配置ipv6" class="headerLink" title="为vpc中的ec2配置ipv6"></a>为VPC中的EC2配置IPv6</h3><p>VPC默认是使用IPv4来组网的，如果想要支持IPv6，创建VPC的时候需要手动指定CIDR IPv6地址段。对于已经创建好的IPv6 VPC，也可以添加IPv6 CIDR。</p><p>和IPv4不同的是，VPC的IPv6 CIDR前缀长度固定为<code>/56</code>。Subnet的IPv6 CIDR固定为<code>/64</code>。而且IPv6的CIDR段不能手动设置，全靠AWS自动分配。</p><blockquote><p>和 IPv4 不同的是 IPv6 地址不区分私有地址和共网地址</p></blockquote><p>要想创建的 EC2 实例添加IPv6，需要满足以下两个条件：<br />- EC2实例所属的Subnet配置了IPv6 CIDR<br />- 创建EC2实例的时候勾选上<code>Auto-assign IPv6 IP</code>设置。如果Subnet设置了<code>Enable auto-assign IPv6 address</code>选项，那么创建EC2的时候不需要再手动选择分配IPv6地址了。</p><blockquote><p>不管Instance的状态是start还是stop，Instance的IPv6地址都不会被释放。只有当Instance Terminate的时候，IPv6地址才会释放。</p></blockquote><p>让一个VPC支持IPv6需要完成一下配置：</p><ul><li>在VPC管理界面，选择想要更改的VPC，右键编辑他的<code>CIDRs</code>，在选项中添加IPv6 CIDR。AWS将自动分配一个IPv6 CIDR。</li><li>找到VPC下面的Subnet，为想要修改的Subnet分配IPv6 CIDR。</li><li>在VPC的主路由表里面添加一行路由表，destination设置为<code>::/0</code>，target为对应网关的ID。让IPv6流量通过网关访问到外网。</li></ul><p>如果想要让一个支持IPv6的Subnet里面的EC2实例支持IPv6，还需要做如下配置：</p><ul><li>在 AWS EC2 管理界面里面选择要修改的EC2实例，在Actions里面选择Manage IP Address选项可以为EC2实例添加IPv6地址。</li><li>修改实例关联的Security Group，添加IPv6地址的Inbound/Outbound规则。</li></ul><p><strong>注意</strong>：虽然在 AWS EC2 管理界面里面为实例分配了IPv6地址，但是操作系统里面未必识别到了IPv6地址。如果实例使用的是Amazon Linux 2016.09.0以后的版本，则实例会自动获得IPv6地址。但是Ubuntu/CentOS系统不能获得IPv6地址，需要在系统里面做进一步配置。</p><p>在Ubuntu 16.04系统里面执行如下命令可以马上获得分配的IPv6地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dhclient -6</span><br></pre></td></tr></table></figure><p>但是这个命令会在系统重启之后失效，为了让下次重启的时候，能够自动IPv6地址，执行下面的命令配置DHCPv6：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces.d/60-default-with-ipv6.cfg</span><br><span class="line">// 在文件中添加: iface eth0 inet6 dhcp</span><br><span class="line"> </span><br><span class="line">sudo ifdown eth0 ; sudo ifup eth0</span><br></pre></td></tr></table></figure><blockquote><p>有时候执行<code>dhclient</code>命令不工作，只能用第二种方法。</p></blockquote><p>为了让新建的Ubuntu实例也自动支持IPv6，需要将这一行加入到UserData中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"iface eth0 inet6 dhcp"</span> &gt;&gt; /etc/network/interfaces.d/60-default-with-ipv6.cfg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Amazon VPC (Virtual Private Cloud) 是AWS的网络基础设施。使用VPC服务可以在AWS中创建一个独立隔离的网络，在这个隔离的网络空间中可以创建任何AWS资源，例如EC2、Redis、RDS数据库等等，VPC网络使这些AWS资源互相连接，传递数据，并且提供外网访问的网关。&lt;/p&gt;
&lt;p&gt;实际上很多人可能不知道，如果你已经在使用AWS的EC2，你就已经在不知不觉中使用了VPC。当我们最开始使用AWS服务时，AWS为我们创建了一个默认的VPC网络，我们创建的EC2实例（如果不手动选择）都默认加入到了这个VPC网络中。EC2、RDS等资源必须创建在一个VPC网路中，才能互相联通，访问网络。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://chenliang.org/categories/DevOps/"/>
    
    
      <category term="AWS" scheme="http://chenliang.org/tags/AWS/"/>
    
  </entry>
  
</feed>
